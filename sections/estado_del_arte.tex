\newpage
~
\newpage
\section{Estado del arte}
Qué se ha hecho hasta ahora en este campo, qué tecnologías se han utilizado, qué problemas se han encontrado, qué soluciones se han propuesto.

% TODO:  Hablar también del estudio de las posibles soluciones, aunque después se elija otra.
%
% Añadir trabajo relacionado, hablar sobre propuestas de otras personas.
%
% Incorporar comparación de las tecnologías planteadas.
% 1. **Inmediato**: Completar análisis de tecnologías móviles
% 2. **Corto plazo**: Añadir métricas cuantitativas y trabajo relacionado
% 3. **Medio plazo**: Desarrollar análisis de arquitecturas y contribución


En este apartado se presenta un análisis del estado del arte en el ámbito de las bibliotecas de archivos multimedia de código abierto (\acrshort{foss}).
Se examinan las principales soluciones disponibles, sus características técnicas, fortalezas y limitaciones, así como las tendencias actuales en el sector.
Dado que uno de los objetivos del proyecto es desarrollar un producto que sea de código abierto, la comparación se centra en soluciones FOSS que ya están en el mercado y que han sido ampliamente adoptadas por la comunidad, lo cual nos va a permitir desarrollar una comparación mas extensa sobre cómo están organizados los proyectos para facilitar su mantenimiento y escalabilidad, así como las tecnologías que utilizan para ofrecer sus servicios.

Además, se realiza un estudio sobre las tecnologías que vamos a utilizar en el proyecto en comparación con las alternativas y las que ya se utilizan en los proyectos existentes que se analizan.

En el panorama actual de las bibliotecas de archivos multimedia de código abierto, existe una amplia variedad de soluciones que buscan ofrecer alternativas libres y gratuitas a los servicios propietarios como Google Photos o iCloud. Este análisis del estado del arte se centra en las tres soluciones más populares según el número de estrellas en GitHub: Immich, PhotoPrism y Ente.

% Fuentes:
% Google Photos: https://photos.google.com/
% Apple Photos: https://www.apple.com/ios/photos/
% Amazon Photos: https://www.amazon.com/photos
% Microsoft OneDrive Photos: https://www.microsoft.com/en-us/microsoft-365/onedrive/online-cloud-storage
\subsection{Soluciones Propietarias Relevantes}

En el ámbito de la gestión y almacenamiento de fotografías, las soluciones propietarias han marcado el estándar en cuanto a experiencia de usuario, integración de servicios y capacidades avanzadas de inteligencia artificial. Entre las plataformas más destacadas se encuentran Google Photos, Apple Photos, Amazon Photos y Microsoft OneDrive Photos, cada una con un enfoque particular y funcionalidades diferenciadoras.

Google Photos sobresale por su motor de búsqueda semántica basado en inteligencia artificial, que permite localizar imágenes mediante descripciones textuales, reconocimiento automático de objetos, lugares y personas, así como la agrupación inteligente de rostros. Además, ofrece funciones como la creación automática de álbumes, recuerdos personalizados, sugerencias de edición y generación de vídeos y animaciones a partir de colecciones de fotos. La integración con Google Assistant permite búsquedas por voz y automatización de tareas relacionadas con la gestión de imágenes.

Apple Photos, por su parte, se integra de forma nativa en el ecosistema de dispositivos Apple, ofreciendo sincronización automática y segura a través de iCloud. Destaca por sus potentes herramientas de edición no destructiva, la organización automática mediante “Memories” y “People”, y la privacidad reforzada mediante el procesamiento local de datos sensibles, como el reconocimiento facial. La integración con Siri permite búsquedas contextuales y sugerencias inteligentes.

Amazon Photos ofrece almacenamiento ilimitado de fotografías en alta resolución para suscriptores de Amazon Prime, así como detección automática de duplicados y organización por personas, lugares y objetos. Su enfoque está orientado a la simplicidad y la capacidad de compartir álbumes de forma privada o pública, además de la integración con dispositivos Amazon Echo Show para visualización mediante comandos de voz.

Microsoft OneDrive Photos integra la gestión de imágenes con el resto de servicios de productividad de Microsoft 365, facilitando la colaboración y el acceso multiplataforma. Incluye funciones de etiquetado automático, búsqueda por contenido visual y organización cronológica, así como integración con herramientas de edición en línea y sincronización con dispositivos Windows y móviles.

Entre las características avanzadas que suelen estar más desarrolladas en estas soluciones propietarias, y que pueden servir de inspiración para el desarrollo de alternativas open-source, destacan:
\begin{itemize}
    \item \textbf{Búsqueda semántica avanzada}: Localización de imágenes mediante descripciones naturales, reconocimiento de escenas, objetos y personas.
    \item \textbf{Agrupación y etiquetado inteligente}: Detección y agrupación automática de rostros, lugares y eventos.
    \item \textbf{Generación automática de recuerdos y contenido}: Creación de álbumes, vídeos y animaciones personalizadas a partir de colecciones de fotos.
    \item \textbf{Integración con asistentes virtuales}: Búsqueda y gestión de imágenes mediante comandos de voz.
    \item \textbf{Sincronización y acceso multiplataforma}: Integración transparente con diferentes dispositivos y sistemas operativos.
    \item \textbf{Herramientas avanzadas de edición}: Edición no destructiva, sugerencias automáticas y filtros inteligentes.
    \item \textbf{Privacidad y control de datos}: Procesamiento local de información sensible y opciones avanzadas de control de acceso.
\end{itemize}

Si bien algunas de estas funcionalidades comienzan a estar presentes en proyectos de código abierto, la madurez, precisión y facilidad de uso de las implementaciones propietarias sigue siendo, en muchos casos, superior debido a la inversión en inteligencia artificial, recursos computacionales y la integración profunda con sus respectivos ecosistemas. La incorporación de estas capacidades en soluciones FOSS representa un reto y una oportunidad para cerrar la brecha funcional existente.

\subsection{Panorama General de Soluciones FOSS}

El ecosistema de bibliotecas de archivos multimedia de código abierto ha experimentado un crecimiento significativo en los últimos años, impulsado por las crecientes preocupaciones sobre la privacidad de los datos y la dependencia de servicios en la nube propietarios. Según el análisis comparativo realizado por Meichthys \parencite{meichthys2024}, existen más de 16 proyectos activos que ofrecen diferentes enfoques y características.

Las soluciones analizadas se pueden clasificar en tres categorías principales:
\begin{itemize}
    \item \textbf{Soluciones escalables}: Enfocadas en escalabilidad y características avanzadas
    \item \textbf{Soluciones centradas en privacidad}: Priorizan la seguridad y el cifrado
    \item \textbf{Soluciones ligeras}: Optimizadas para recursos limitados
\end{itemize}

\subsection{Análisis de las Tres Soluciones Principales}

\subsubsection{Immich}

Immich es una solución de gestión de fotos de código abierto orientada a usuarios que buscan una alternativa privada y autoalojada a servicios comerciales como Google Photos. Su desarrollo comenzó en 2022 y ha experimentado un rápido crecimiento gracias a una comunidad activa y a la adopción de tecnologías modernas.

\textbf{Propósito y público objetivo:} Immich está diseñado para usuarios particulares, familias y pequeños equipos que desean mantener el control sobre sus fotos y vídeos, evitando la dependencia de servicios en la nube de terceros. Es especialmente atractivo para entusiastas de la tecnología y defensores de la privacidad.

\textbf{Historia y contexto:} El proyecto nació como respuesta a la falta de alternativas libres y modernas a los grandes servicios comerciales, con un enfoque en la experiencia de usuario y la facilidad de despliegue.

\textbf{Modelo de desarrollo:} Immich es mantenido principalmente por una comunidad de desarrolladores en GitHub, con contribuciones frecuentes y una hoja de ruta pública.

\textbf{Características funcionales:}
\begin{itemize}
    \item \textbf{Facilidad de uso:} Interfaz web moderna, intuitiva y responsiva, con aplicaciones móviles para Android e iOS.
    \item \textbf{Instalación y despliegue:} Ofrece imágenes Docker y documentación clara, facilitando la instalación en servidores personales o NAS.
    \item \textbf{Soporte multiplataforma:} Disponible en web y dispositivos móviles, con sincronización automática desde el móvil.
    \item \textbf{Idiomas disponibles:} Traducción a varios idiomas, incluyendo español, gracias a la colaboración comunitaria.
    \item \textbf{Tecnologías:} Backend en NestJS/Node.js, frontend en SvelteKit, móvil en Flutter, base de datos PostgreSQL y Redis, IA con TensorFlow.
\end{itemize}

\textbf{Comunidad y ecosistema:}
\begin{itemize}
    \item \textbf{Comunidad activa:} Foros, Discord y GitHub con alta participación.
    \item \textbf{Documentación:} Completa y en constante actualización.
    \item \textbf{Extensibilidad:} API pública y soporte para integraciones futuras.
\end{itemize}

\textbf{Seguridad y privacidad:}
\begin{itemize}
    \item \textbf{Gestión de datos personales:} Los datos permanecen en el servidor del usuario, sin envíos a terceros.
    \item \textbf{Cifrado:} Actualmente no implementa cifrado de extremo a extremo, pero sí buenas prácticas de seguridad en el almacenamiento y acceso.
    \item \textbf{Actualizaciones:} Lanzamientos frecuentes y respuesta rápida a vulnerabilidades.
\end{itemize}

\textbf{Casos de uso y ejemplos reales:}
\begin{itemize}
    \item Utilizado por usuarios domésticos y pequeñas organizaciones para gestionar colecciones fotográficas privadas.
    \item Referencias y testimonios positivos en foros de autoalojamiento y privacidad.
\end{itemize}

\textbf{Limitaciones actuales:}
\begin{itemize}
    \item Alto consumo de recursos debido a Node.js.
    \item API en constante evolución (menos estable).
    \item Compatibilidad limitada con carpetas existentes.
    \item Algunas funciones avanzadas (como la edición colaborativa o el reconocimiento facial avanzado) están en desarrollo.
    \item La integración con otros servicios y dispositivos aún es limitada en comparación con soluciones comerciales.
\end{itemize}

\subsubsection{PhotoPrism}

PhotoPrism es una de las soluciones FOSS más maduras y populares para la gestión de fotos, con una comunidad consolidada y un enfoque en la organización eficiente y el respeto a la privacidad.

\textbf{Propósito y público objetivo:} Orientado a usuarios que buscan una alternativa autoalojada, robusta y fácil de usar para organizar grandes colecciones de fotos, con especial atención a la preservación de metadatos y la integración con sistemas existentes.

\textbf{Historia y contexto:} Lanzado en 2017, PhotoPrism ha evolucionado para convertirse en una referencia dentro del software libre de gestión fotográfica, con un desarrollo sostenido y una base de usuarios creciente.

\textbf{Modelo de desarrollo:} Proyecto comunitario con liderazgo claro, financiado parcialmente por donaciones y patrocinios.

\textbf{Características funcionales:}
\begin{itemize}
    \item \textbf{Facilidad de uso:} Interfaz web clara y funcional, con enfoque en la organización y búsqueda eficiente.
    \item \textbf{Instalación y despliegue:} Instalación sencilla mediante Docker o binarios, compatible con múltiples sistemas operativos.
    \item \textbf{Soporte multiplataforma:} Acceso desde cualquier navegador y soporte PWA para móviles.
    \item \textbf{Idiomas disponibles:} Traducción a numerosos idiomas.
    \item \textbf{Tecnologías:} Backend en Go, frontend en Vue.js, base de datos SQLite/MariaDB, almacenamiento local con archivos sidecar.
\end{itemize}

\textbf{Comunidad y ecosistema:}
\begin{itemize}
    \item \textbf{Comunidad consolidada:} Foros, GitHub y canales de soporte activos.
    \item \textbf{Documentación:} Muy completa y detallada.
    \item \textbf{Extensibilidad:} Limitada, pero con integración básica mediante API y archivos sidecar.
\end{itemize}

\textbf{Seguridad y privacidad:}
\begin{itemize}
    \item \textbf{Gestión de datos personales:} Los datos permanecen bajo control del usuario.
    \item \textbf{Cifrado:} No implementa cifrado de extremo a extremo, pero permite despliegues seguros en redes privadas.
    \item \textbf{Actualizaciones:} Ciclo de lanzamientos estable y respuesta adecuada a incidencias.
\end{itemize}

\textbf{Casos de uso y ejemplos reales:}
\begin{itemize}
    \item Utilizado por fotógrafos, familias y pequeñas empresas para organizar y buscar fotos de forma eficiente.
    \item Referencias en comunidades de software libre y autoalojamiento.
\end{itemize}

\textbf{Limitaciones actuales:}
\begin{itemize}
    \item Soporte limitado para múltiples usuarios.
    \item Escalabilidad horizontal restringida.
    \item Aplicaciones móviles limitadas a PWA, sin apps nativas.
    \item No utiliza una estructura estandarizada para la organización, dificultando la contribución de terceros.
\end{itemize}

\subsubsection{Ente}

Ente destaca por su enfoque radical en la privacidad y la seguridad, ofreciendo cifrado de extremo a extremo y una experiencia multiplataforma coherente gracias a Flutter.

\textbf{Propósito y público objetivo:} Dirigido a usuarios que priorizan la privacidad y la seguridad de sus fotos, como periodistas, activistas o cualquier persona preocupada por la confidencialidad de sus datos.

\textbf{Historia y contexto:} Proyecto joven pero con rápido crecimiento, impulsado por la demanda de soluciones seguras y privadas en el ámbito de la gestión fotográfica.

\textbf{Modelo de desarrollo:} Comunidad activa y transparente, con desarrollo abierto y enfoque en la seguridad.

\textbf{Características funcionales:}
\begin{itemize}
    \item \textbf{Facilidad de uso:} Interfaz moderna y coherente en todas las plataformas.
    \item \textbf{Instalación y despliegue:} Sencillo para usuarios finales, con apps en tiendas oficiales y opción de autoalojamiento.
    \item \textbf{Soporte multiplataforma:} Apps nativas para móvil y escritorio, y versión web.
    \item \textbf{Idiomas disponibles:} Traducción en expansión gracias a la comunidad.
    \item \textbf{Tecnologías:} Backend en Go, frontend y apps en Flutter, base de datos PostgreSQL, cifrado client-side.
\end{itemize}

\textbf{Comunidad y ecosistema:}
\begin{itemize}
    \item \textbf{Comunidad creciente:} Participación activa en GitHub y foros.
    \item \textbf{Documentación:} Clara y orientada a la seguridad.
    \item \textbf{Extensibilidad:} Limitada por el enfoque en la privacidad.
\end{itemize}

\textbf{Seguridad y privacidad:}
\begin{itemize}
    \item \textbf{Gestión de datos personales:} Cifrado de extremo a extremo, arquitectura de conocimiento cero.
    \item \textbf{Cifrado:} Todos los datos se cifran en el cliente antes de ser almacenados.
    \item \textbf{Actualizaciones:} Rápida respuesta a vulnerabilidades y mejoras continuas en seguridad.
\end{itemize}

\textbf{Casos de uso y ejemplos reales:}
\begin{itemize}
    \item Adoptado por usuarios preocupados por la privacidad y organizaciones que manejan información sensible.
    \item Recomendado en foros de privacidad y seguridad digital.
\end{itemize}

\textbf{Limitaciones actuales:}
\begin{itemize}
    \item Overhead del cifrado afecta el rendimiento.
    \item Características de IA limitadas por la privacidad.
    \item No se utiliza ninguna estructura de repositorio, dificultando la aportación al proyecto.
\end{itemize}

\subsection{Comparación Técnica Detallada}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Característica} & \textbf{Immich} & \textbf{PhotoPrism} & \textbf{Ente} \\
\hline
Estrellas GitHub & 66,988 & 37,499 & 19,431 \\
Lenguaje Principal & TypeScript & Go & \gls{dart} \\
Arquitectura & Microservicios & Monolítica & Cliente-Servidor \\
Base de Datos & PostgreSQL & SQLite/MySQL & PostgreSQL \\
Aplicación Móvil & Flutter (8/10) & PWA (4/10) & Flutter (8/10) \\
Reconocimiento IA & 9/10 & 9/10 & En desarrollo \\
Múltiples Usuarios & 8/10 & No soportado & 9/10 \\
Búsqueda & 9/10 & 8/10 & 6/10 \\
Privacidad & 7/10 & 8/10 & 10/10 \\
Facilidad de Contribución & Alta & Baja & Baja-Media \\
\hline
\end{tabular}
\caption{Comparación técnica de las principales soluciones FOSS}
\label{tab:tech_comparison}
\end{table}

A continuación se explican brevemente las características comparadas en la tabla anterior:

\textbf{Estrellas GitHub:} Indica la popularidad y el nivel de interés de la comunidad en cada proyecto, reflejando tanto la visibilidad como la actividad de usuarios y desarrolladores.

\textbf{Lenguaje Principal:} Se refiere al lenguaje de programación predominante en el desarrollo del proyecto, lo que puede influir en la facilidad de contribución, el rendimiento y la compatibilidad con otras tecnologías.

\textbf{Arquitectura:} Describe el enfoque estructural del software. Una arquitectura de microservicios facilita la escalabilidad y el mantenimiento, mientras que una arquitectura monolítica puede simplificar el despliegue. El modelo cliente-servidor, por su parte, suele estar orientado a la seguridad y la separación de responsabilidades.

\textbf{Base de Datos:} Indica el sistema de gestión de bases de datos utilizado para almacenar la información. La elección de la base de datos afecta el rendimiento, la escalabilidad y la facilidad de integración con otros sistemas.

\textbf{Aplicación Móvil:} Evalúa la calidad y el tipo de experiencia móvil ofrecida, diferenciando entre aplicaciones nativas (mayor rendimiento y funcionalidad) y aplicaciones web progresivas (PWA), que suelen ser más limitadas.

\textbf{Reconocimiento IA:} Hace referencia a las capacidades de inteligencia artificial para el reconocimiento de imágenes, como la detección de rostros, objetos o escenas, y su grado de madurez en cada solución.

\textbf{Múltiples Usuarios:} Indica el soporte para la gestión de varios usuarios en la misma instancia, lo que es relevante para entornos familiares, de equipos o empresas.

\textbf{Búsqueda:} Evalúa la potencia y precisión de los mecanismos de búsqueda y filtrado de imágenes, incluyendo la búsqueda por metadatos, texto o reconocimiento automático.

\textbf{Privacidad:} Analiza el nivel de protección de los datos del usuario, considerando aspectos como el cifrado, la arquitectura de conocimiento cero y la gestión local de la información.

\textbf{Facilidad de Contribución:} Se refiere a la facilidad con la que nuevos desarrolladores pueden colaborar en el proyecto, influida por la calidad de la documentación y la modularidad del código.

\subsection{Análisis de Rendimiento}

El análisis de rendimiento revela diferentes enfoques optimizados para casos de uso específicos:

\textbf{Immich} sobresale en escalabilidad y características avanzadas, pero requiere más recursos del servidor. Su arquitectura de microservicios permite el escalado horizontal y la distribución de carga de trabajo, especialmente beneficial para el procesamiento de IA.

\textbf{PhotoPrism} ofrece la mejor eficiencia de recursos gracias a Go y su arquitectura monolítica, siendo ideal para instalaciones en hardware limitado. Su procesamiento de archivos es especialmente eficiente para fotógrafos profesionales.

\textbf{Ente} equilibra el rendimiento con la seguridad, trasladando el procesamiento al cliente para mantener la privacidad, aunque esto introduce latencia en las operaciones de cifrado/descifrado.

\subsection{Tendencias y Evolución del Sector}

El análisis del estado del arte revela varias tendencias importantes:

\begin{enumerate}
    \item \textbf{Migración hacia arquitecturas modernas}: Immich lidera esta tendencia con TypeScript y microservicios
    \item \textbf{Enfoque en la privacidad}: Ente representa la vanguardia en soluciones privacy-first
    \item \textbf{Madurez y estabilidad}: PhotoPrism ejemplifica la importancia de la estabilidad a largo plazo
    \item \textbf{Convergencia móvil}: Flutter se está estableciendo como la tecnología preferida para aplicaciones móviles
\end{enumerate}

\subsection{Conclusiones}

El ecosistema de bibliotecas de archivos multimedia FOSS presenta tres paradigmas distintos que abordan diferentes necesidades del mercado. Immich representa la innovación y escalabilidad, PhotoPrism la madurez y eficiencia, mientras que Ente pionerea en privacidad y seguridad.

Esta diversidad de enfoques indica un mercado en maduración donde no existe una solución única, sino que cada proyecto optimiza para casos de uso específicos. La elección entre estas soluciones depende fundamentalmente de los requisitos de escalabilidad, privacidad, recursos disponibles y experiencia técnica del usuario final.

El análisis sugiere que el futuro del sector se dirigirá hacia la convergencia de estas características, buscando soluciones que combinen la escalabilidad de Immich, la eficiencia de PhotoPrism y la privacidad de Ente.

Además, las nuevas tecnologías como pueden ser \gls{react-native} o en este caso \gls{lynxjs}, pueden aportar un mejor desarrollo de una aplicación móvil nativa, que permita una mejor experiencia de usuario y un mejor rendimiento en dispositivos móviles sin perder características nativas de las plataformas.

No se ve en ningún proyecto entre los más populares que haga uso de \gls{rust}. Aunque hay una tendencia a utilizar Go, el cual es un lenguaje que es más sencillo y proporciona un rendimiento muy bueno, Rust ofrece ventajas significativas en términos de seguridad y rendimiento, especialmente para aplicaciones que requieren un alto grado de concurrencia y eficiencia en el manejo de memoria. Esto sugiere una oportunidad para explorar Rust como una alternativa viable para el desarrollo de bibliotecas de archivos multimedia FOSS en el futuro.

Por lo general, se suele hacer uso de un almacenamiento de objetos ya implementado, como puede ser \gls{minio}, que es compatible con \gls{s3}. Esto permite una mayor escalabilidad y flexibilidad en el almacenamiento de grandes volúmenes de datos, lo cual es esencial para aplicaciones que manejan grandes bibliotecas de archivos multimedia.
Aún así, sería interesante explorar la posibilidad de implementar un almacenamiento de objetos propio, ya que esto podría ofrecer ventajas en términos de personalización y optimización para casos de uso específicos como puede ser el caso en el que ya se tiene un almacenamiento de archivos en el servidor y se quiere aprovechar para almacenar las fotos.

\subsection{Estudio de Tecnologías}

Tal y como se puede ver en el apartado anterior, hay una tendencia general a usar Typescript o Go para el desarrollo de el servidor de sincronización de multimedia y Flutter o PWA para el desarrollo de aplicaciones móviles. Sin embargo, existen otras tecnologías que pueden ofrecer ventajas significativas en términos de rendimiento, seguridad y facilidad de desarrollo.

En este caso, se va a estudiar el uso de Rust para el desarrollo del servidor de sincronización de multimedia, ya que ofrece un alto rendimiento y seguridad en la gestión de memoria, lo cual es crucial para aplicaciones que manejan grandes volúmenes de datos como las bibliotecas de archivos multimedia.
La seguridad que nos da Rust con su modelo de errores antes de la compilación nos va a permitir desarrollar un proyecto de código abierto más robusto y menos propenso a errores.

Se estudiarán las tecnologías disponibles para el desarrollo de la aplicación móvil, entre ellas React Native, Flutter, PWA y Lynx.js. Cada una de estas tecnologías tiene sus propias ventajas y desventajas, y la elección de la tecnología adecuada dependerá de los requisitos específicos del proyecto, como la necesidad de una experiencia de usuario nativa, el rendimiento en dispositivos móviles y la facilidad de desarrollo.

\subsubsection{Servidor}
El servidor de sincronización de multimedia es el componente central de la aplicación, encargado de gestionar la comunicación entre el cliente y el almacenamiento de fotos.
Disponemos de una amplia variedad a la hora de elegir un lenguaje/\gls{framework} para el desarrollo del servidor, cada uno con sus propias ventajas y desventajas.

Las principales soluciones serían:
\begin{itemize}
    \item \textbf{Node.js con TypeScript}: Muy popular, especialmente para aplicaciones web. Ofrece un ecosistema rico y una gran comunidad, siendo menos eficiente en términos de rendimiento y consumo de recursos con respecto a su competencia.
    \item \textbf{Go}: Conocido por su eficiencia y facilidad de uso en aplicaciones concurrentes. Es una opción sólida para aplicaciones que requieren alto rendimiento y escalabilidad.
    \item \textbf{Rust}: Ofrece un alto rendimiento y seguridad en la gestión de memoria. Aunque tiene una curva de aprendizaje más pronunciada, es ideal para aplicaciones que requieren alta concurrencia y eficiencia.
    \item \textbf{Python}: Muy utilizado en el ámbito de la ciencia de datos y aprendizaje automático, pero menos eficiente en términos de rendimiento y escalabilidad para aplicaciones web, además de contar con un \gls{tipado-dinamico} que puede llevar a errores en tiempo de ejecución.
    \item \textbf{Java}: Aunque es robusto y escalable, su complejidad y consumo de recursos lo hacen menos atractivo para aplicaciones ligeras.
    \item \textbf{Ruby on Rails}: Muy popular para aplicaciones web, pero menos eficiente en términos de rendimiento y escalabilidad. No se ha trabajado mucho con esta tecnología, por lo que no se tiene una experiencia directa con ella.
\end{itemize}

Dado que para nuestro proyecto buscamos la solución más eficiente (tanto en términos de velocidad como recursos) y segura, el análisis se puede reducir a una comparación entre Go y Rust, lenguajes que ofrecen un alto rendimiento y seguridad en la gestión de memoria.

Rust y Go son dos lenguajes de programación modernos que han ganado una popularidad considerable en los últimos años, especialmente en el desarrollo de sistemas y aplicaciones de alto rendimiento. Aunque ambos comparten objetivos como la eficiencia y la concurrencia, sus filosofías de diseño y enfoques para resolver problemas difieren significativamente.

\textbf{Rust} es un lenguaje de programación de sistemas enfocado en la seguridad de memoria y la concurrencia. Su principal objetivo es ofrecer el rendimiento de C/C++ sin los problemas comunes de gestión de memoria, como los punteros nulos o las \glspl{condicion-carrera}, gracias a su sistema de propiedad (\gls{rust-ownership}) y préstamos (\gls{rust-borrowing}).

\textbf{Go} (también conocido como Golang) es un lenguaje desarrollado por Google, diseñado para ser simple, eficiente y productivo, especialmente para la programación concurrente y de redes. Prioriza la simplicidad en su sintaxis y herramientas, facilitando una curva de aprendizaje suave.

\paragraph{Gestión de Memoria}
\subparagraph{Rust}
Rust implementa un sistema de gestión de memoria único basado en los conceptos de \textit{ownership}, \textit{borrowing} y \textit{\glspl{rust-lifetimes}}. Este sistema garantiza la seguridad de memoria en tiempo de compilación sin necesidad de un \acrfull{gc}.

El sistema de gestión de memoria de Rust se basa en las siguientes reglas:
\begin{itemize}
    \item Cada valor en Rust tiene un único propietario (owner).
    \item Cuando el propietario sale del ámbito, el valor se libera automáticamente.
    \item Los valores pueden ser prestados (borrowed) de forma mutable o inmutable, pero no ambos al mismo tiempo.
    \item Solamente puede haber un préstamo mutable o múltiples préstamos inmutables a un valor al mismo tiempo. Un préstamo mutable no puede existir a la vez que un préstamo inmutable, dado que podría llevar a condiciones de carrera.
    \item Los préstamos tienen una duración (lifetime) que garantiza que los datos referenciados sigan siendo válidos durante su uso. El tiempo de vida de los préstamos se determina en tiempo de compilación, lo que evita errores comunes de punteros nulos o dangling pointers.
\end{itemize}

Gracias a ello, tenemos control preciso sobre la memoria, ausencia de pausas por GC, prevención de fugas de memoria y carreras de datos de forma estática. El compilador será muy estricto, lo que hará que prevengamos errores en tiempo de ejecución.

Todo este paradigma de programación es totalmente distinto a lo que estamos acostumbrados en otros lenguajes de programación como puede ser Java o c++/c, lo que puede llevar a una curva de aprendizaje más pronunciada, pero a largo plazo nos va a permitir desarrollar aplicaciones más seguras y eficientes.

\subparagraph{Go}
Go utiliza un recolector de basura para la gestión automática de la memoria. Este GC está optimizado para baja latencia, aunque introduce ciertas pausas.
\begin{itemize}
    \item \textbf{Ventajas:} Simplifica la gestión de memoria para el desarrollador, haciendo más sencillo el desarrollo de aplicaciones concurrentes. El lenguaje es más fácil de aprender y usar, especialmente para principiantes.
    \item \textbf{Desventajas:} Introduce una sobrecarga (overhead) y posibles pausas no determinísticas debido al GC, lo que puede ser un inconveniente en aplicaciones de tiempo real estricto.
\end{itemize}

\paragraph{Rendimiento}
\subparagraph{Rust}
Rust está diseñado para ofrecer un rendimiento comparable al de C y C++. Sus abstracciones de "coste cero" aseguran que las características de alto nivel no impongan una penalización en tiempo de ejecución. La ausencia de GC también contribuye a un rendimiento predecible.

Rust ofrece varias abstracciones de coste cero como \texttt{iterators}, \texttt{closures} y \texttt{async/await} que permiten escribir código limpio y expresivo sin sacrificar el rendimiento. Además, su sistema de tipos y el modelo de propiedad permiten al compilador realizar optimizaciones agresivas que en otro lenguaje son imposibles.

En el rendimiento podemos distinguir entre dos aspectos:
\begin{itemize}
    \item \textbf{Compilación:} Los tiempos de compilación pueden ser más largos debido a las exhaustivas verificaciones que realiza el compilador.
    \item \textbf{Ejecución:} Muy alta velocidad de ejecución y uso eficiente de los recursos.
\end{itemize}

\subparagraph{Go}
Go ofrece un buen rendimiento, aunque generalmente no alcanza el nivel de Rust o C++ en tareas que requieren máxima optimización a bajo nivel. Su compilador es notablemente rápido.

Go utiliza un modelo de concurrencia basado en \glspl{goroutine} y canales, lo que permite un alto grado de paralelismo sin complicaciones adicionales. Esto lo hace ideal para aplicaciones que requieren manejar múltiples tareas simultáneamente, como servidores web o servicios de red.

\begin{itemize}
    \item \textbf{Compilación:} Tiempos de compilación muy rápidos, lo que agiliza el ciclo de desarrollo.
    \item \textbf{Ejecución:} Buen rendimiento para la mayoría de las aplicaciones, especialmente en \acrshort{i-o} y concurrencia. El GC puede impactar el rendimiento en ciertos escenarios.
\end{itemize}

\paragraph{Concurrencia}
\subparagraph{Rust}
Rust aborda la concurrencia con un enfoque en la seguridad ("\gls{fearless-concurrency}"). Su sistema de tipos y el modelo de propiedad previenen las carreras de datos en tiempo de compilación. Utiliza primitivas como \texttt{async/await} para la programación asíncrona, además de hilos de sistema operativo, consiguiendo paralelismo para la programación asíncrona.

Rust permite la creación de hilos seguros y eficientes, y su modelo de propiedad garantiza que no haya condiciones de carrera. El compilador verifica en tiempo de compilación que no se acceda a datos compartidos de forma insegura gracias a su modelo de propiedad de variables, lo que reduce significativamente los errores comunes en la programación concurrente.
\begin{itemize}
    \item \textbf{Ventajas:} Concurrencia segura sin condiciones de carrera garantizada por el compilador. Buen soporte para paralelismo.
    \item \textbf{Desventajas:} La programación concurrente puede ser más verbosa o compleja de configurar inicialmente en comparación con Go.
\end{itemize}

\subparagraph{Go}
La concurrencia es una de las características estrella de Go. Se basa en \textit{goroutines} y \textit{canales} (channels) para la comunicación entre goroutines, siguiendo el paradigma de \acrfull{csp}.
Éste se basa en la idea de que las goroutines se comunican entre sí a través de canales sin acceder a las mismas posiciones de memoria (cada goroutine tiene su propia copia de el mensaje) y reduce el riesgo de condiciones de carrera.
Si queremos tener una comunicación bidireccional, tendríamos que utilizar un enfoque más tradicional mediante \glspl{mutex} o \glspl{semaforo} junto con \glspl{lock}, lo cual puede ser más complejo y propenso a errores.
\begin{itemize}
    \item \textbf{Ventajas:} Modelo de concurrencia muy simple y potente. Facilidad para escribir software concurrente y paralelo.
    \item \textbf{Desventajas:} Aunque las goroutines son ligeras, una mala gestión puede llevar a problemas de rendimiento o fugas de goroutines. Las condiciones de carrera son posibles y deben ser manejadas por el desarrollador.
\end{itemize}

\paragraph{Sintaxis y Curva de Aprendizaje}
\subparagraph{Rust}
La sintaxis de Rust es moderna y expresiva, pero su sistema de tipos y el modelo de gestión de memoria (ownership y borrowing) introducen una curva de aprendizaje considerablemente más pronunciada que la de Go.
Ya se ha trabajado anteriormente con Rust, lo cual facilita el aprendizaje de este lenguaje.
Además, la documentación oficial de Rust es muy completa y está bien estructurada, contando con el libro oficial de rust \parencite{rustbook2021}, que ayuda a los nuevos usuarios a familiarizarse con el lenguaje.
\begin{itemize}
    \item \textbf{Ventajas:} Sintaxis potente que permite un control muy granular.
    \item \textbf{Desventajas:} Dificultad inicial alta para dominar los conceptos clave.
\end{itemize}

\subparagraph{Go}
Go fue diseñado con la simplicidad como uno de sus principios fundamentales. Su sintaxis es minimalista y fácil de aprender, especialmente para programadores con experiencia en lenguajes tipo C.
\begin{itemize}
    \item \textbf{Ventajas:} Curva de aprendizaje suave, alta legibilidad y productividad rápida.
    \item \textbf{Desventajas:} La simplicidad puede llevar a cierta verbosidad en algunos casos (por ejemplo, el manejo de errores antes de la versión 1.13 con \texttt{wrap error}). Algunos patrones comunes de otros lenguajes no tienen un equivalente directo.
\end{itemize}

\paragraph{Sistema de Tipos y Abstracciones}
\subparagraph{Rust}
Rust posee un sistema de tipos estático, fuerte y muy rico, inspirado en lenguajes como \gls{haskell}. Incluye \textit{\gls{rust-traits}}, genéricos avanzados, \acrlong{adt} \gls{adt-gls} como \texttt{enum} y \texttt{struct} que, gracias a el \gls{pattern-matching}, y macros para \gls{metaprogramacion}.
\begin{itemize}
    \item \textbf{Ventajas:} Gran expresividad, seguridad de tipos, permite abstracciones potentes y seguras.
    \item \textbf{Desventajas:} Puede resultar complejo para quienes vienen de lenguajes con sistemas de tipos más simples.
\end{itemize}

\subparagraph{Go}
Go tiene un sistema de tipos estático y simple. Utiliza interfaces para la polimorfismo de forma implícita (tipado estructural). Los genéricos fueron añadidos en la versión 1.18, lo que ha expandido sus capacidades de abstracción.
\begin{itemize}
    \item \textbf{Ventajas:} Simplicidad en el sistema de tipos, interfaces fáciles de usar. La adición de genéricos ha mejorado la reutilización de código.
    \item \textbf{Desventajas:} Menos expresivo que el sistema de tipos de Rust. Antes de los genéricos, la falta de ellos era una limitación importante.
\end{itemize}

\paragraph{Ecosistema y Herramientas}
\subparagraph{Rust}
Rust cuenta con \textbf{Cargo}, una herramienta de gestión de dependencias y construcción de proyectos muy elogiada. El repositorio oficial de paquetes es \textbf{crates.io}, que alberga una cantidad creciente de bibliotecas.

Cargo además ofrece herramientas integradas para pruebas, documentación y gestión de versiones.
\begin{itemize}
    \item \textbf{Ventajas:} Herramientas robustas y unificadas. Comunidad activa y creciente.
    \item \textbf{Desventajas:} Aunque el ecosistema está creciendo rápidamente, puede no ser tan maduro como el de Go en ciertas áreas específicas (ej. algunas bibliotecas para servicios web muy específicos).
\end{itemize}

\subparagraph{Go}
Go posee una excelente librería estándar que cubre muchas necesidades comunes, especialmente en networking y servicios web. Sus herramientas de desarrollo (formateo, testing, profiling) están integradas en la distribución del lenguaje. Utiliza módulos de Go para la gestión de dependencias.
\begin{itemize}
    \item \textbf{Ventajas:} Librería estándar muy completa. Herramientas simples y efectivas. Compilación cruzada sencilla.
    \item \textbf{Desventajas:} Menor cantidad de bibliotecas de terceros para ciertos dominios muy especializados en comparación con lenguajes más antiguos, aunque el ecosistema es maduro para sus casos de uso principales.
\end{itemize}

\paragraph{Manejo de Errores}
\subparagraph{Rust}
Rust no utiliza excepciones. El manejo de errores se realiza principalmente a través de los tipos \texttt{Result<T, E>} y \texttt{Option<T>} y el pattern matching exhaustivo, que obligan al programador a considerar los casos de éxito y error explícitamente.
\begin{itemize}
    \item \textbf{Ventajas:} Manejo de errores robusto y explícito, que previene errores no gestionados.
    \item \textbf{Desventajas:} Puede resultar verboso en comparación con las excepciones, aunque el operador \texttt{?}\footnote{El operador ? devuelve el error si ocurre sin necesidad de introducir un \textit{match}} ayuda a mitigar esto.
\end{itemize}

\subparagraph{Go}
Go maneja los errores retornándolos como el último valor de una función. Por convención, un error es un valor que satisface la interfaz \texttt{error}. Esto requiere comprobaciones explícitas \texttt{if err != nil}.
El manejo de errores en este caso no es exhaustivo.
\begin{itemize}
    \item \textbf{Ventajas:} Simple y explícito.
    \item \textbf{Desventajas:} Puede llevar a código repetitivo y verboso con múltiples comprobaciones de error.
\end{itemize}

\paragraph{Casos de Uso Principales}
\subparagraph{Rust}
\begin{itemize}
    \item Programación de sistemas (sistemas operativos, navegadores web).
    \item Motores de videojuegos.
    \item \acrfull{cli}.
    \item Desarrollo en \gls{webassembly} (WASM).
    \item Sistemas embebidos.
    \item Aplicaciones que requieren alto rendimiento y seguridad de memoria.
\end{itemize}

\subparagraph{Go}
\begin{itemize}
    \item Servicios de backend y microservicios.
    \item Herramientas de red y servidores.
    \item Herramientas de \gls{devops} y CLI.
    \item Bases de datos distribuidas.
    \item Aplicaciones concurrentes.
\end{itemize}

\paragraph{Resumen de Ventajas y Desventajas}

\subparagraph{Rust}
\textbf{Ventajas:}
\begin{itemize}
    \item Seguridad de memoria sin recolector de basura.
    \item Alto rendimiento, comparable a C/C++.
    \item Concurrencia segura ("fearless concurrency").
    \item Sistema de tipos rico y expresivo.
    \item Excelente gestor de paquetes y herramientas (Cargo).
    \item Creciente popularidad en dominios críticos.
\end{itemize}
\textbf{Desventajas:}
\begin{itemize}
    \item Curva de aprendizaje pronunciada.
    \item Tiempos de compilación más lentos.
    \item Mayor verbosidad en algunos aspectos debido a la gestión de memoria y errores.
\end{itemize}

\subparagraph{Go}
\textbf{Ventajas:}
\begin{itemize}
    \item Simplicidad y facilidad de aprendizaje.
    \item Modelo de concurrencia simple y potente (goroutines, channels).
    \item Tiempos de compilación muy rápidos.
    \item Librería estándar robusta.
    \item Buena productividad para el desarrollo de servicios de red.
    \item Respaldo de Google y una comunidad madura.
\end{itemize}
\textbf{Desventajas:}
\begin{itemize}
    \item Rendimiento generalmente inferior a Rust en cómputo intensivo.
    \item El recolector de basura puede introducir latencias.
    \item El sistema de tipos es menos expresivo que el de Rust (aunque mejorado con genéricos).
    \item El manejo de errores puede ser verboso.
\end{itemize}

\paragraph{Conclusión}
\subparagraph{}
Para este caso, cualquiera de las dos soluciones sería completamente válida. Go podría ser la mejor opción por su enfoque en la simplicidad y la facilidad de uso, especialmente para aplicaciones web y servicios de red. Sin embargo, Rust ofrece ventajas significativas en términos de seguridad de memoria y rendimiento, lo que lo convierte en una opción atractiva para aplicaciones que requieren alta concurrencia y eficiencia.

En nuestro proyecto se busca alto rendimiento, seguridad, facilidad de contribuir al proyecto y un lenguaje sólido que no sea propenso a fallos.
Es por esto que Rust es la mejor opción en nuestro caso.

Tal como se ha comentado anteriormente, Rust nos facilita seguridad en la ejecución del código gracias a su estricto compilador.
Nos ofrece una gran variedad de funcionalidades sin coste en rendimiento junto con su sistema de propiedad y préstamos que nos permite gestionar la memoria de forma segura y eficiente, evitando errores comunes como las condiciones de carrera o los punteros nulos sin necesidad de un recolector de basura (GC).

Aunque la curva de aprendizaje de Rust es más pronunciada, los beneficios a largo plazo en términos de seguridad y rendimiento justifican esta inversión inicial.

Invertir en aprender este lenguaje no solo nos favorecerá para el desarrollo de este proyecto, sino que también nos proporcionará habilidades valiosas para futuros proyectos en el ámbito del desarrollo de software, el cual al final es uno de los objetivos de hacer un proyecto de este tamaño.

Trabajar con tecnologías y paradigmas de programación con las que no estamos familiarizados nos ayudará a mejorar nuestras habilidades y ampliar nuestro conocimiento en el desarrollo de software, lo cual es esencial para nuestro crecimiento profesional.

\subsubsection{Aplicación Móvil}

Para el desarrollo de aplicaciones móviles en el contexto de bibliotecas de archivos multimedia, existen varias tecnologías que ofrecen diferentes enfoques y características. A continuación se presenta un análisis detallado de las principales opciones disponibles.

\paragraph{React Native}

React Native, desarrollado por Meta (Facebook), permite crear aplicaciones móviles nativas utilizando JavaScript y React. Es ampliamente adoptado en la industria y cuenta con un ecosistema maduro.

\textbf{Arquitectura y Funcionamiento:}
\begin{itemize}
    \item Utiliza un \gls{bridge} para comunicar JavaScript con componentes nativos
    \item Renderiza componentes nativos reales, no WebViews
    \item Permite integración de código nativo cuando es necesario
    \item Soporte para hot reload durante el desarrollo
\end{itemize}

\textbf{Ventajas:}
\begin{itemize}
    \item \textbf{Ecosistema maduro}: Gran cantidad de bibliotecas y componentes disponibles
    \item \textbf{Comunidad activa}: Amplio soporte de la comunidad y documentación extensa
    \item \textbf{Desarrollo rápido}: Reutilización de código entre iOS y Android (70-80\%)
    \item \textbf{Performance nativa}: Acceso directo a APIs nativas del dispositivo
    \item \textbf{Flexibilidad}: Posibilidad de escribir módulos nativos cuando sea necesario
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item \textbf{Bridge overhead}: La comunicación JavaScript-nativo puede introducir latencias
    \item \textbf{Tamaño de aplicación}: Las aplicaciones tienden a ser más grandes debido a las dependencias
    \item \textbf{Fragmentación}: Diferentes versiones pueden tener incompatibilidades
    \item \textbf{Limitaciones de UI}: Algunos componentes complejos requieren implementación nativa
\end{itemize}

\paragraph{Flutter}

Flutter, desarrollado por Google, utiliza el lenguaje Dart y un enfoque único de renderizado que dibuja todos los componentes desde cero utilizando \gls{skia}.

\textbf{Arquitectura y Funcionamiento:}
\begin{itemize}
    \item Engine compilado en C++ que renderiza directamente con Skia
    \item Framework en Dart que gestiona widgets y estado
    \item Compilación \gls{ahead-of-time} (AOT) para producción
    \item Hot reload y hot restart para desarrollo
\end{itemize}

\textbf{Ventajas:}
\begin{itemize}
    \item \textbf{Rendimiento consistente}: 60\acrshort{fps} garantizados en la mayoría de dispositivos
    \item \textbf{UI personalizable}: Control total sobre cada píxel de la interfaz
    \item \textbf{Consistencia multiplataforma}: Misma apariencia en iOS y Android
    \item \textbf{Desarrollo productivo}: \Gls{hot-reload} extremadamente rápido
    \item \textbf{Compilación nativa}: Sin bridge, comunicación directa con APIs nativas
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item \textbf{Curva de aprendizaje}: Dart es menos conocido que JavaScript
    \item \textbf{Tamaño de aplicación}: El engine de Flutter añade peso significativo (4-8MB base)
    \item \textbf{Ecosistema más joven}: Menos bibliotecas de terceros comparado con React Native
    \item \textbf{Plataformas específicas}: Algunas funcionalidades requieren plugins específicos
    \item \textbf{Limitaciones de integración}: Puede ser complicado integrar con código nativo existente
    \item \textbf{Renderizado sobre motor gráfico}: Dado que no renderiza de manera nativa, puede ser menos eficiente en dispositivos de gama baja
\end{itemize}

\paragraph{Progressive Web Apps (PWA)}

Las PWA representan una evolución de las aplicaciones web tradicionales, ofreciendo características similares a las aplicaciones nativas mediante tecnologías web estándar.

\textbf{Arquitectura y Funcionamiento:}
\begin{itemize}
    \item \Glspl{service-worker} para funcionalidad offline y caché
    \item Web App Manifest para instalación y apariencia nativa
    \item Responsive design para adaptación a diferentes dispositivos
    \item APIs web modernas para acceso a funcionalidades del dispositivo
\end{itemize}

\textbf{Ventajas:}
\begin{itemize}
    \item \textbf{Desarrollo unificado}: Una sola base de código para web y móvil
    \item \textbf{Distribución sencilla}: No requiere app stores, actualización automática
    \item \textbf{Peso reducido}: Generalmente más ligeras que aplicaciones nativas
    \item \textbf{Accesibilidad}: Funcionan en cualquier dispositivo con navegador moderno
    \item \textbf{SEO}: Indexables por motores de búsqueda
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item \textbf{Limitaciones de API}: Acceso restringido a funcionalidades nativas
    \item \textbf{Rendimiento}: Inferior a aplicaciones nativas para tareas intensivas
    \item \textbf{Experiencia de usuario}: Puede sentirse menos "nativa"
    \item \textbf{Soporte variable}: Diferencias de implementación entre navegadores
    \item \textbf{Distribución}: Menor visibilidad sin presencia en app stores
\end{itemize}

\paragraph{Lynx.js}

Lynx.js representa una tecnología emergente que promete combinar el desarrollo web con el rendimiento nativo, aunque su adopción y madurez son significativamente menores que las alternativas establecidas.

\textbf{Arquitectura y Funcionamiento:}
\begin{itemize}
    \item Runtime nativo que ejecuta JavaScript sin WebView
    \item Compilación just-in-time optimizada para móviles
    \item Bridge optimizado para comunicación JavaScript-nativo
    \item Soporte para APIs nativas modernas
    \item Uso de doble thread para mejorar el rendimiento y experiencia de usuario
\end{itemize}

\textbf{Ventajas:}
\begin{itemize}
    \item \textbf{Rendimiento optimizado}: Promete mejor rendimiento que React Native gracias a su ejecución con doble thread
    \item \textbf{Tamaño reducido}: Runtime más ligero que Flutter
    \item \textbf{Desarrollo familiar}: Utiliza JavaScript/TypeScript estándar
    \item \textbf{APIs modernas}: Soporte nativo para funcionalidades actuales
    \item \textbf{Interoperabilidad}: Posibilidad de integrar código nativo fácilmente, de manera similar a React Native
    \item \textbf{Actualizaciones}: Desarrollado y utilizado por el equipo de TikTok, lo que promete actualizaciones y mejoras constantes
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item \textbf{Tecnología inmadura}: Ecosistema limitado y documentación escasa
    \item \textbf{Comunidad pequeña}: Pocos recursos y ejemplos disponibles
    \item \textbf{Estabilidad}: Versiones alpha/beta con cambios frecuentes
    \item \textbf{Compatibilidad}: Posibles problemas con bibliotecas existentes
\end{itemize}

\subsubsection{Comparación de Tecnologías Móviles}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Criterio} & \textbf{React Native} & \textbf{Flutter} & \textbf{PWA} & \textbf{Lynx.js} \\
\hline
Rendimiento & 7/10 & 9/10 & 5/10 & 8/10* \\
Ecosistema & 9/10 & 8/10 & 8/10 & 3/10 \\
Curva Aprendizaje & 6/10 & 7/10 & 9/10 & 7/10 \\
Tamaño App & 6/10 & 5/10 & 9/10 & 8/10* \\
Acceso Nativo & 9/10 & 9/10 & 4/10 & 8/10* \\
Desarrollo Rápido & 8/10 & 9/10 & 9/10 & 6/10 \\
Estabilidad & 9/10 & 8/10 & 8/10 & 4/10 \\
Comunidad & 9/10 & 8/10 & 7/10 & 2/10 \\
\hline
\multicolumn{5}{|l|}{*Datos basados en especificaciones, experiencia limitada} \\
\hline
\end{tabular}
\caption{Comparación de tecnologías para desarrollo móvil}
\label{tab:mobile_tech_comparison}
\end{table}

\subsubsection{Análisis de Rendimiento para Bibliotecas de Fotos}

Para aplicaciones de gestión de fotos, ciertos aspectos del rendimiento son particularmente críticos:

\paragraph{Procesamiento de Imágenes}
\begin{itemize}
    \item \textbf{Flutter}: Excelente para manipulación de imágenes gracias a Skia
    \item \textbf{React Native}: Requiere bibliotecas nativas para procesamiento intensivo
    \item \textbf{PWA}: Limitado a Canvas API y \gls{webgl}, rendimiento variable
    \item \textbf{Lynx.js}: Promete buen rendimiento, pero sin datos empíricos
\end{itemize}

\paragraph{Gestión de Memoria}
\begin{itemize}
    \item \textbf{Flutter}: Control granular de memoria, garbage collection optimizado
    \item \textbf{React Native}: Dependiente de JavaScript GC, posibles memory leaks
    \item \textbf{PWA}: Gestión automática del navegador, limitaciones en dispositivos antiguos
    \item \textbf{Lynx.js}: Optimizaciones prometidas pero no verificadas
\end{itemize}

\paragraph{Carga y Visualización}
\begin{itemize}
    \item \textbf{Flutter}: \Gls{lazy-loading} nativo y caching eficiente
    \item \textbf{React Native}: Buenas bibliotecas para lazy loading (react-native-fast-image)
    \item \textbf{PWA}: Service Workers para caching, pero limitaciones de almacenamiento
    \item \textbf{Lynx.js}: Lazy loading integrado y optimizado mediante componente específico para carga de datos/imágenes
\end{itemize}

\subsubsection{Consideraciones Específicas para el Proyecto}

Dado que el proyecto busca crear una biblioteca de fotos FOSS competitiva, la elección de tecnología móvil debe considerar:

\paragraph{Criterios de Decisión}
\begin{enumerate}
    \item \textbf{Rendimiento}: Crítico para manipulación de grandes colecciones de fotos
    \item \textbf{Experiencia de Usuario}: Debe rivalizar con soluciones comerciales
    \item \textbf{Facilidad de Contribución}: Importante para proyectos FOSS
    \item \textbf{Sostenibilidad}: Tecnología con futuro asegurado
\end{enumerate}

\paragraph{Conclusiones}
Basándose en el análisis comparativo y los requisitos específicos del proyecto:

\textbf{Flutter es una opción sólida} por las siguientes razones:
\begin{itemize}
    \item Consistencia multiplataforma ideal para FOSS
    \item Ecosistema maduro con soporte a largo plazo de Google
    \item Buena integración con APIs, aunque integración con \acrfull{acr} limitada
    \item Comunidad activa en proyectos de código abierto
\end{itemize}

\textbf{React Native podría ser la mejor opción} si se prioriza:
\begin{itemize}
    \item Familiaridad del equipo con JavaScript
    \item Acceso a un ecosistema más amplio de bibliotecas
    \item Flexibilidad para integraciones nativas específicas
\end{itemize}

\textbf{PWA es una mala opción} ya que:
\begin{itemize}
    \item Se requiera distribución app stores, de forma no nativa
    \item Bajo rendimiento a la hora de realizar tareas intensivas de procesamiento de imágenes
    \item Limitaciones en acceso a funcionalidades nativas del dispositivo
\end{itemize}

\textbf{Lynx.js es una opción arriesgada} aunque ofrece ventajas como:
\begin{itemize}
    \item Rendimiento optimizado y menor tamaño de aplicación
    \item Desarrollo familiar con JavaScript/TypeScript
    \item Potencial para mejorar la experiencia de usuario en comparación con React Native
\end{itemize}

Para el desarrollo de este proyecto se va a optar por usar \textbf{Lynx.js}.

Aunque es una elección que puede parecer arriesgada, se ha considerado que el rendimiento optimizado y la familiaridad con JavaScript/TypeScript son factores clave para el éxito del proyecto.
Además, el hecho de que Lynx.js esté respaldado por TikTok sugiere un compromiso a largo plazo con la tecnología, lo que puede ofrecer estabilidad y actualizaciones continuas.

Se ha descartado React Native ya que Lynx.js ofrece prácticamente las mismas ventajas, pero con un rendimiento optimizado gracias a componentes específicos optimizados, un tamaño de aplicación más reducido y un acceso más directo a las APIs nativas del dispositivo.

Flutter aun ofreciendo una gran cantidad de ventajas se ha descartado por lo siguiente:
\begin{itemize}
    \item El tamaño de la aplicación es significativamente mayor que el de Lynx.js, lo cual puede ser un inconveniente para los usuarios con dispositivos de gama baja.
    \item Aunque ofrece un rendimiento excelente, la curva de aprendizaje de Dart puede ser un obstáculo para algunos desarrolladores, especialmente si ya están familiarizados con JavaScript/TypeScript, lo cual afectaría a la facilidad de contribuir al proyecto.
    \item Para dispositivos de gama baja, además de el tamaño de la aplicación, el rendimiento puede verse afectado por el uso intensivo del motor gráfico de Flutter, lo que podría resultar en una experiencia de usuario deficiente.
    \item El acceso a funcionalidades nativas puede ser más complicado en comparación con Lynx.js, que permite una integración más directa con el código nativo existente.
\end{itemize}
Cabe destacar que Flutter habría sido la mejor elección si el objetivo del proyecto no fuera crear una aplicación FOSS, ya que el ecosistema de Typescript y JavaScript es más amplio y maduro, lo que facilita la integración con bibliotecas y herramientas existentes.

\paragraph{Tecnologías no nombradas}
Durante el análisis nos hemos centrado en aquellas tecnologías que son más populares y ampliamente utilizadas en la industria, pero existen otras opciones que podrían ser consideradas dependiendo de los requisitos específicos del proyecto como podría ser el desarrollo nativo (Kotlin/Java para Android y Swift/Objective-C para iOS) o Kotlin Multiplatform.

Se han descartado debido a la alta curva de aprendizaje que tienen ambas soluciones en comparación con las anteriormente nombradas que usan lenguajes de programación más usados. Destacar que, aunque Kotlin Multiplaform nos ofrece una de las mejores alternativas para implementar en varias plataformas (ya que nos permite compartir código entre Android, iOS y web gracias a \gls{jetpack-compose}, implementando de forma sencilla y totalmente nativa funcionalidades específicas), la falta de madurez en su ecosistema y la complejidad de su implementación lo hacen menos atractivo para nuestro proyecto.

\subsection{Análisis de Costes}

El análisis de costes es un aspecto fundamental a la hora de evaluar las diferentes soluciones de bibliotecas de archivos multimedia FOSS. Este análisis abarca varios aspectos que impactan directamente en el coste total de implementación y mantenimiento.

\subsubsection{Requisitos de Hardware}

Los requisitos de hardware varían significativamente entre las diferentes soluciones:

\begin{itemize}
    \item \textbf{Immich}:
    \begin{itemize}
        \item Rendimiento óptimo con procesador moderno (por ejemplo, Intel NUC de 12ª generación)
        \item Mínimo 16GB de RAM recomendado para bibliotecas grandes
        \item Almacenamiento SSD para la base de datos y caché
        \item Almacenamiento NAS/HDD para los archivos originales
    \end{itemize}

    \item \textbf{PhotoPrism}:
    \begin{itemize}
        \item Requiere hardware más potente para un rendimiento similar
        \item Mínimo 16GB de RAM, preferiblemente 32GB para bibliotecas grandes
        \item GPU integrada recomendada para aceleración por hardware
        \item SSD local para miniaturas y caché
    \end{itemize}

    \item \textbf{Ente}:
    \begin{itemize}
        \item Requisitos moderados debido al cifrado client-side
        \item 8-16GB de RAM suficientes para la mayoría de casos
        \item Menor dependencia de GPU
    \end{itemize}
\end{itemize}

\subsubsection{Consumo de Recursos}

El consumo de recursos afecta directamente a los costes operativos:

\begin{itemize}
    \item \textbf{Almacenamiento}:
    \begin{itemize}
        \item Immich: Genera dos miniaturas por imagen, altamente configurable
        \item PhotoPrism: Genera 8 miniaturas JPEG con diferentes relaciones de aspecto
        \item Ente: Uso eficiente del almacenamiento debido al cifrado
    \end{itemize}

    \item \textbf{Procesamiento}:
    \begin{itemize}
        \item Immich: Procesamiento paralelo eficiente, menor impacto en CPU
        \item PhotoPrism: Mayor uso de CPU durante la indexación y procesamiento
        \item Ente: Sobrecarga adicional debido al cifrado
    \end{itemize}
\end{itemize}

\subsubsection{Costes de Mantenimiento}

Los costes de mantenimiento incluyen:

\begin{itemize}
    \item \textbf{Actualizaciones y Parches}:
    \begin{itemize}
        \item Immich: Actualizaciones frecuentes, proceso automatizado
        \item PhotoPrism: Desarrollo más lento, actualizaciones menos frecuentes
        \item Ente: Ciclo de desarrollo moderado
    \end{itemize}

    \item \textbf{Backup y Redundancia}:
    \begin{itemize}
        \item Todas las soluciones requieren estrategias de backup
        \item Costes adicionales para almacenamiento redundante
        \item Necesidad de monitorización y mantenimiento regular
    \end{itemize}
\end{itemize}

\subsubsection{Costes de Escalabilidad}

La escalabilidad impacta en los costes a largo plazo:

\begin{itemize}
    \item \textbf{Vertical}:
    \begin{itemize}
        \item Immich: Mejor rendimiento con hardware modesto
        \item PhotoPrism: Puede requerir actualizaciones de hardware más frecuentes
        \item Ente: Escalado limitado por el cifrado
    \end{itemize}

    \item \textbf{Horizontal}:
    \begin{itemize}
        \item Immich: Arquitectura de microservicios facilita la escalabilidad
        \item PhotoPrism: Limitaciones en escalabilidad horizontal
        \item Ente: Diseño centrado en privacidad limita opciones de escalado
    \end{itemize}
\end{itemize}

\subsubsection{Modelos de Monetización}

Es importante considerar los diferentes modelos de monetización:

\begin{itemize}
    \item \textbf{Immich}:
    \begin{itemize}
        \item Completamente gratuito y open source
        \item Sin funciones premium o de pago
        \item Financiado por donaciones y comunidad
    \end{itemize}

    \item \textbf{PhotoPrism}:
    \begin{itemize}
        \item Modelo freemium
        \item Algunas características avanzadas requieren suscripción
        \item Membresías Plus y Pro disponibles
    \end{itemize}

    \item \textbf{Ente}:
    \begin{itemize}
        \item Enfoque en privacidad y seguridad
        \item Modelo de negocio basado en donaciones
    \end{itemize}
\end{itemize}

\subsection{Análisis Comparativo de Métricas}

A partir de pruebas realizadas por la comunidad y documentación oficial, se presenta un análisis detallado de las métricas de rendimiento y capacidades de las tres soluciones principales.

\subsubsection{Rendimiento de Procesamiento}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Métrica} & \textbf{Immich} & \textbf{PhotoPrism} & \textbf{Ente} \\
\hline
Velocidad de Indexación & Alta & Media-Baja & Media \\
Tiempo de Carga UI & $<$1s & 1-2s & $<$1s \\
Procesamiento Paralelo & Sí & No & Parcial \\
Uso de CPU & Moderado & Alto & Bajo \\
\hline
\end{tabular}
\caption{Comparación de métricas de rendimiento}
\label{tab:performance_metrics}
\end{table}

\subsubsection{Gestión de Almacenamiento}

\begin{itemize}
    \item \textbf{Miniaturas por Imagen}:
    \begin{itemize}
        \item Immich: 2 miniaturas configurables
        \item PhotoPrism: 8 miniaturas JPEG (diferentes relaciones de aspecto)
        \item Ente: Optimizado para cifrado, número variable
    \end{itemize}

    \item \textbf{Espacio de Caché}:
    \begin{itemize}
        \item Immich: Aproximadamente 1.5x el tamaño original
        \item PhotoPrism: 2-3x el tamaño original
        \item Ente: 1-1.5x el tamaño original
    \end{itemize}
\end{itemize}

\subsubsection{Precisión de Reconocimiento}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Característica} & \textbf{Immich} & \textbf{PhotoPrism} & \textbf{Ente} \\
\hline
Detección Facial & 90\% & 60\% & 85\% \\
Reconocimiento de Objetos & 85\% & 70\% & No disponible \\
Agrupación de Fotos & Excelente & Buena & Limitada \\
Precisión de Búsqueda & Alta & Media & Media \\
\hline
\end{tabular}
\caption{Comparación de precisión en características de IA}
\label{tab:ai_accuracy}
\end{table}

\subsubsection{Tiempos de Procesamiento}

Para una biblioteca de prueba de 40,000 imágenes (aproximadamente 1.6TB):

\begin{itemize}
    \item \textbf{Immich}:
    \begin{itemize}
        \item Importación inicial: 2-3 horas
        \item Indexación completa: 4-6 horas
        \item Generación de miniaturas: 3-4 horas
        \item Procesamiento de IA: 6-8 horas
    \end{itemize}

    \item \textbf{PhotoPrism}:
    \begin{itemize}
        \item Importación inicial: 4-5 horas
        \item Indexación completa: 24-48 horas
        \item Generación de miniaturas: 8-10 horas
        \item Procesamiento de IA: 12-24 horas
    \end{itemize}

    \item \textbf{Ente}:
    \begin{itemize}
        \item Importación inicial: 3-4 horas
        \item Indexación completa: 8-10 horas
        \item Generación de miniaturas: 4-5 horas
        \item Procesamiento de IA: No aplicable
    \end{itemize}
\end{itemize}

\subsubsection{Métricas de Escalabilidad}

\begin{itemize}
    \item \textbf{Límites de Biblioteca}:
    \begin{itemize}
        \item Immich: Probado con $>$1 millón de fotos
        \item PhotoPrism: Recomendado hasta 500,000 fotos
        \item Ente: Probado con $>$250,000 fotos
    \end{itemize}

    \item \textbf{Rendimiento con Carga}:
    \begin{itemize}
        \item Immich: Mantiene rendimiento con múltiples usuarios
        \item PhotoPrism: Degradación notable con múltiples usuarios
        \item Ente: Rendimiento constante pero limitado
    \end{itemize}
\end{itemize}

\subsubsection{Soporte de Formatos}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Formato} & \textbf{Immich} & \textbf{PhotoPrism} & \textbf{Ente} \\
\hline
JPEG & Sí & Sí & Sí \\
RAW & Parcial & Completo & No \\
HEIC & Sí & Sí & Parcial \\
Videos & Sí & Sí & Limitado \\
Live Photos & Sí & No & No \\
\hline
\end{tabular}
\caption{Comparación de soporte de formatos}
\label{tab:format_support}
\end{table}

\subsection{Interoperabilidad y Estándares Abiertos}

La interoperabilidad y el uso de estándares abiertos son factores clave para la adopción y sostenibilidad de las bibliotecas de archivos multimedia FOSS. Permiten a los usuarios migrar fácilmente sus datos, integrar la aplicación con otros servicios y evitar el "vendor lock-in". A continuación se analiza cómo las principales soluciones abordan estos aspectos:

\begin{itemize}
    \item \textbf{Integración con servicios externos}: Immich y PhotoPrism ofrecen soporte para almacenamiento externo mediante protocolos como \gls{webdav} y S3 (Amazon Simple Storage Service o compatibles como MinIO), facilitando la integración con soluciones de almacenamiento en la nube o NAS. Ente, por su enfoque en privacidad, limita la integración a servicios que no comprometan la seguridad de los datos.
    \item \textbf{Soporte de estándares de metadatos}: PhotoPrism destaca por su soporte completo de estándares como EXIF, \acrshort{iptc} y \acrshort{xmp} para metadatos, permitiendo una mejor interoperabilidad con otras aplicaciones de gestión de fotos. Immich y Ente ofrecen soporte parcial, centrado principalmente en EXIF.
    \item \textbf{Exportación e importación}: Todas las soluciones permiten la exportación e importación de fotos y metadatos, aunque el grado de automatización y compatibilidad varía. PhotoPrism facilita la migración mediante herramientas específicas y documentación detallada. Immich permite la importación desde carpetas existentes, pero la exportación masiva puede requerir herramientas adicionales. Ente prioriza la exportación cifrada para mantener la privacidad.
    \item \textbf{Federación y APIs}: Ninguna de las soluciones principales implementa actualmente protocolos de federación como \gls{activity-pub}, aunque existen discusiones en la comunidad sobre su posible adopción futura. Todas ofrecen APIs REST para integración con aplicaciones de terceros, aunque el grado de estabilidad y documentación varía (Immich tiene una API en evolución, PhotoPrism una API más estable).
\end{itemize}

La adopción de estándares abiertos y la interoperabilidad son aspectos en los que aún existe margen de mejora en el sector. Fomentar la compatibilidad con protocolos y formatos ampliamente aceptados facilitará la integración con otros sistemas y la migración de datos, beneficiando tanto a usuarios finales como a desarrolladores.


\subsection{Conclusiones}
\subsubsection{Conclusiones del Análisis de Métricas}

El análisis de métricas revela que Immich destaca en varios aspectos clave:

\begin{itemize}
    \item Mayor eficiencia en procesamiento paralelo
    \item Mejor equilibrio entre almacenamiento y funcionalidad
    \item Superior precisión en reconocimiento facial y de objetos
    \item Mejor escalabilidad para bibliotecas grandes
\end{itemize}

PhotoPrism, aunque más maduro, muestra limitaciones en rendimiento y escalabilidad, mientras que Ente destaca en privacidad pero con funcionalidades más limitadas. Estas métricas refuerzan la elección de tecnologías y arquitectura para nuestro proyecto, que busca combinar la eficiencia de Immich con mejoras adicionales en rendimiento y funcionalidad.

\subsubsection{Conclusiones del Análisis de Costes}

El análisis de costes revela que Immich ofrece la mejor relación coste-beneficio para la mayoría de los casos de uso:

\begin{itemize}
    \item Requisitos de hardware más moderados
    \item Mejor eficiencia en el uso de recursos
    \item Arquitectura que facilita la escalabilidad
    \item Modelo completamente gratuito sin costes ocultos
\end{itemize}

Sin embargo, la elección final dependerá de factores específicos como:
\begin{itemize}
    \item Tamaño de la biblioteca de fotos
    \item Recursos de hardware disponibles
    \item Necesidades de escalabilidad
    \item Presupuesto para mantenimiento
\end{itemize}

Para nuestro proyecto, el análisis de costes refuerza la decisión de utilizar tecnologías eficientes como Rust y Lynx.js, que permitirán minimizar los requisitos de hardware y los costes operativos mientras se mantiene un alto nivel de rendimiento.

\subsubsection{Conclusiones Interoperabilidad y Estándares Abiertos}
El análisis de interoperabilidad y estándares abiertos muestra que Immich y PhotoPrism son las soluciones más avanzadas en este aspecto, con un enfoque claro en la integración con servicios externos y el uso de metadatos estandarizados. Ente, aunque prioriza la privacidad, limita la interoperabilidad al restringir la integración con servicios externos.

En nuestra propuesta buscamos fomentar la interoperabilidad mediante el uso de estándares abiertos y APIs bien documentadas, lo que permitirá a los usuarios migrar fácilmente sus datos y contribuir al proyecto. Esto es esencial para garantizar la sostenibilidad a largo plazo y la adopción por parte de la comunidad.
Gracias a esto se busca que el proyecto no solo sea una solución de gestión de fotos, sino también un ecosistema abierto y colaborativo que permita a los usuarios y desarrolladores contribuir y beneficiarse mutuamente, además de poder integrar la aplicación con otros servicios y herramientas existentes.

\subsection{Aportaciones de nuestro proyecto al estado del arte}
Una vez realizado un estudio de las soluciones existentes y las tecnologías más utilizadas en el desarrollo de aplicaciones móviles y web, se ha identificado una clara oportunidad para mejorar la experiencia del usuario en la gestión de bibliotecas de archivos multimedia.

Nuestro proyecto busca abordar las limitaciones actuales de las aplicaciones de fotos, especialmente en términos de rendimiento, usabilidad, facilidad de aportación al proyecto y características avanzadas.
\subsubsection{Rendimiento}
El rendimiento es un aspecto crítico en las aplicaciones de fotos, especialmente cuando se manejan grandes colecciones. Muchas aplicaciones existentes sufren de lentitud en la carga y visualización de imágenes, lo que afecta negativamente la experiencia del usuario.
No solo se busca optimizar la carga de imágenes en la aplicación, sino mejorar la velocidad de respuesta que ofrece el servidor a la hora de recibir, procesar y responder a las peticiones de los usuarios.

Todo esto lo conseguiremos gracias a:
\begin{itemize}
    \item Aplicación móvil programada en Lynx.js, que permite un rendimiento optimizado mediante el uso de componentes específicos para la carga de datos e imágenes, así como un acceso más directo a las APIs nativas del dispositivo. Aunque es una tecnología emergente, utiliza JavaScript/TypeScript con su propia variante de React, lo que facilita la curva de aprendizaje para desarrolladores familiarizados con estas tecnologías.
    \item Servidor programado en Rust, que ofrece alto rendimiento, eficiencia en la gestión de recursos y acceso a optimizaciones a bajo nivel, lo que se traduce en una respuesta más rápida a las peticiones de los usuarios. Usar Rust nos va a proporcionar un código más seguro y eficiente, evitando errores comunes como las condiciones de carrera o los punteros nulos sin necesidad de un recolector de basura (GC).
\end{itemize}
\subsubsection{Contribución al proyecto}
Nuestro proyecto no solo se centrará en ofrecer una aplicación de fotos, sino que también se diseñará como un proyecto FOSS, lo que permitirá a la comunidad contribuir y mejorar la aplicación de manera continua.

Para ello se hará uso de las mejoras prácticas de desarrollo de software:
\begin{itemize}
    \item Uso de control de versiones (\Gls{git}), documentación clara y accesible, y un proceso de revisión de código que fomente la colaboración y la calidad del código.
    \item Se implementará una estructura de proyecto que facilite la incorporación de nuevos desarrolladores, con guías claras sobre cómo contribuir y estándares de codificación.
    \item El uso de Rust también aporta valor a nuestro proyecto al ofrecer un lenguaje moderno y seguro que minimiza los errores comunes de programación, lo que facilita la colaboración y la contribución de nuevos desarrolladores, eliminando posibles errores en la aplicación incluso antes de que se ejecute.
    \item Utilizaremos TypeScript en la aplicación móvil, lo que permitirá a los desarrolladores familiarizados con JavaScript contribuir fácilmente al proyecto, lo que facilitará la incorporación de nuevos colaboradores y fomentará una comunidad activa.
    \item Implementación de pruebas unitarias y de integración para asegurar la calidad del código y la funcionalidad de la aplicación.
\end{itemize}
