\newpage
~
\newpage
\section{Estado del arte}
Qué se ha hecho hasta ahora en este campo, qué tecnologías se han utilizado, qué problemas se han encontrado, qué soluciones se han propuesto.

% TODO:  Hablar también del estudio de las posibles soluciones, aunque después se elija otra.
%
% Añadir trabajo relacionado, hablar sobre propuestas de otras personas.
%
% Incorporar comparación de las tecnologías planteadas.
% 1. **Inmediato**: Completar análisis de tecnologías móviles
% 2. **Corto plazo**: Añadir métricas cuantitativas y trabajo relacionado
% 3. **Medio plazo**: Desarrollar análisis de arquitecturas y contribución


En este apartado se presenta un análisis del estado del arte en el ámbito de las bibliotecas de fotos de código abierto (FOSS).
Se examinan las principales soluciones disponibles, sus características técnicas, fortalezas y limitaciones, así como las tendencias actuales en el sector.
Dado que uno de los objetivos del proyecto es desarrollar un producto que sea de código abierto, la comparación se centra en soluciones FOSS que ya están en el mercado y que han sido ampliamente adoptadas por la comunidad, lo cual nos va a permitir desarrollar una comparación mas extensa sobre cómo están organizados los proyectos para facilitar su mantenimiento y escalabilidad, así como las tecnologías que utilizan para ofrecer sus servicios.

Además, se realiza un estudio sobre las tecnologías que vamos a utilizar en el proyecto en comparación con las alternativas y las que ya se utilizan en los proyectos analizados.

En el panorama actual de las bibliotecas de fotos de código abierto, existe una amplia variedad de soluciones que buscan ofrecer alternativas libres y gratuitas a los servicios propietarios como Google Photos o iCloud. Este análisis del estado del arte se centra en las tres soluciones más populares según el número de estrellas en GitHub: Immich, PhotoPrism y Ente.

\subsection{Panorama General de Soluciones FOSS}

El ecosistema de bibliotecas de fotos de código abierto ha experimentado un crecimiento significativo en los últimos años, impulsado por las crecientes preocupaciones sobre la privacidad de los datos y la dependencia de servicios en la nube propietarios. Según el análisis comparativo realizado por Meichthys \cite{meichthys2024}, existen más de 16 proyectos activos que ofrecen diferentes enfoques y características.

Las soluciones analizadas se pueden clasificar en tres categorías principales:
\begin{itemize}
    \item \textbf{Soluciones escalables}: Enfocadas en escalabilidad y características avanzadas
    \item \textbf{Soluciones centradas en privacidad}: Priorizan la seguridad y el cifrado
    \item \textbf{Soluciones ligeras}: Optimizadas para recursos limitados
\end{itemize}

\subsection{Análisis de las Tres Soluciones Principales}

\subsubsection{Immich}

Immich se posiciona como la solución más popular con 66,988 estrellas en GitHub. Desarrollado principalmente en TypeScript, utiliza una arquitectura de microservicios moderna que incluye:

\begin{itemize}
    \item \textbf{Backend}: NestJS con Node.js
    \item \textbf{Frontend}: SvelteKit para la interfaz web
    \item \textbf{Móvil}: Aplicaciones nativas desarrolladas en Flutter
    \item \textbf{Base de datos}: PostgreSQL con Redis para caché
    \item \textbf{IA/ML}: TensorFlow para reconocimiento facial y de objetos
\end{itemize}

\textbf{Fortalezas técnicas}:
\begin{itemize}
    \item Arquitectura escalable horizontalmente
    \item Excelente experiencia móvil (8/10 según la evaluación)
    \item Capacidades avanzadas de búsqueda (9/10)
    \item Soporte completo para LivePhotos (9/10)
    \item Reconocimiento de imágenes con IA
\end{itemize}

\textbf{Limitaciones}:
\begin{itemize}
    \item Alto consumo de recursos debido a Node.js
    \item API en constante evolución (menos estable)
    \item Compatibilidad limitada con carpetas existentes
\end{itemize}

\subsubsection{PhotoPrism}

PhotoPrism, con 37,499 estrellas en GitHub, representa la solución más madura del ecosistema. Desarrollado en Go, utiliza una arquitectura monolítica que ofrece:

\begin{itemize}
    \item \textbf{Backend}: Aplicación monolítica en Go
    \item \textbf{Frontend}: Vue.js
    \item \textbf{Móvil}: Progressive Web App (PWA)
    \item \textbf{Base de datos}: SQLite, MariaDB
    \item \textbf{Almacenamiento}: Sistema de archivos local con archivos sidecar
\end{itemize}

\textbf{Fortalezas técnicas}:
\begin{itemize}
    \item Bajo consumo de memoria y recursos
    \item Excelente manejo de metadatos EXIF (9/10)
    \item Integración superior con carpetas existentes (9/10)
\end{itemize}

\textbf{Limitaciones}:
\begin{itemize}
    \item Soporte limitado para múltiples usuarios
    \item Escalabilidad horizontal restringida
    \item Aplicaciones móviles limitadas a PWA. No es una aplicación nativa, si no una aplicación web
    \item No se utiliza una estructura estandarizada para la organización, dificultando la contribución de terceros al proyecto
\end{itemize}

\subsubsection{Ente}

Ente, con 19,431 estrellas en GitHub, se distingue por su enfoque en la privacidad. Utiliza Flutter para ofrecer consistencia multiplataforma:

\begin{itemize}
    \item \textbf{Backend}: Go con arquitectura de conocimiento cero
    \item \textbf{Frontend}: Flutter Web
    \item \textbf{Móvil y Desktop}: Flutter nativo
    \item \textbf{Base de datos}: PostgreSQL con cifrado
    \item \textbf{Seguridad}: Cifrado de extremo a extremo client-side
\end{itemize}

\textbf{Fortalezas técnicas}:
\begin{itemize}
    \item Cifrado de extremo a extremo
    \item Consistencia multiplataforma con Flutter
    \item Excelente soporte para múltiples usuarios (9/10)
\end{itemize}

\textbf{Limitaciones}:
\begin{itemize}
    \item No se utiliza ninguna estructura de repositorio, dificultando la aportación al proyecto
    \item Overhead del cifrado afecta el rendimiento
    \item Características de IA limitadas por la privacidad
\end{itemize}

\subsection{Comparación Técnica Detallada}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Característica} & \textbf{Immich} & \textbf{PhotoPrism} & \textbf{Ente} \\
\hline
Estrellas GitHub & 66,988 & 37,499 & 19,431 \\
Lenguaje Principal & TypeScript & Go & Dart \\
Arquitectura & Microservicios & Monolítica & Cliente-Servidor \\
Base de Datos & PostgreSQL & SQLite/MySQL & PostgreSQL \\
Aplicación Móvil & Flutter (8/10) & PWA (4/10) & Flutter (8/10) \\
Reconocimiento IA & 9/10 & 9/10 & En desarrollo \\
Múltiples Usuarios & 8/10 & No soportado & 9/10 \\
Búsqueda & 9/10 & 8/10 & 6/10 \\
Privacidad & 7/10 & 8/10 & 10/10 \\
Facilidad de Contribución & Alta & Baja & Baja-Media \\
\hline
\end{tabular}
\caption{Comparación técnica de las principales soluciones FOSS}
\label{tab:tech_comparison}
\end{table}

\subsection{Análisis de Rendimiento}

El análisis de rendimiento revela diferentes enfoques optimizados para casos de uso específicos:

\textbf{Immich} sobresale en escalabilidad y características avanzadas, pero requiere más recursos del servidor. Su arquitectura de microservicios permite el escalado horizontal y la distribución de carga de trabajo, especialmente beneficial para el procesamiento de IA.

\textbf{PhotoPrism} ofrece la mejor eficiencia de recursos gracias a Go y su arquitectura monolítica, siendo ideal para instalaciones en hardware limitado. Su procesamiento de archivos es especialmente eficiente para fotógrafos profesionales.

\textbf{Ente} equilibra el rendimiento con la seguridad, trasladando el procesamiento al cliente para mantener la privacidad, aunque esto introduce latencia en las operaciones de cifrado/descifrado.

\subsection{Tendencias y Evolución del Sector}

El análisis del estado del arte revela varias tendencias importantes:

\begin{enumerate}
    \item \textbf{Migración hacia arquitecturas modernas}: Immich lidera esta tendencia con TypeScript y microservicios
    \item \textbf{Enfoque en la privacidad}: Ente representa la vanguardia en soluciones privacy-first
    \item \textbf{Madurez y estabilidad}: PhotoPrism ejemplifica la importancia de la estabilidad a largo plazo
    \item \textbf{Convergencia móvil}: Flutter se está estableciendo como la tecnología preferida para aplicaciones móviles
\end{enumerate}

\subsection{Conclusiones del Estado del Arte}

El ecosistema de bibliotecas de fotos FOSS presenta tres paradigmas distintos que abordan diferentes necesidades del mercado. Immich representa la innovación y escalabilidad, PhotoPrism la madurez y eficiencia, mientras que Ente pionerea en privacidad y seguridad.

Esta diversidad de enfoques indica un mercado en maduración donde no existe una solución única, sino que cada proyecto optimiza para casos de uso específicos. La elección entre estas soluciones depende fundamentalmente de los requisitos de escalabilidad, privacidad, recursos disponibles y experiencia técnica del usuario final.

El análisis sugiere que el futuro del sector se dirigirá hacia la convergencia de estas características, buscando soluciones que combinen la escalabilidad de Immich, la eficiencia de PhotoPrism y la privacidad de Ente.

Además, las nuevas tecnologías como pueden ser React Native o en este caso Lynxjs, pueden aportar un mejor desarrollo de una aplicación móvil nativa, que permita una mejor experiencia de usuario y un mejor rendimiento en dispositivos móviles sin perder características nativas de las plataformas.

No se ve en ningún proyecto entre los más populares que haga uso de Rust. Aunque hay una tendencia a utilizar Go, el cual es un lenguaje que es más sencillo y proporciona un rendimiento muy bueno, Rust ofrece ventajas significativas en términos de seguridad y rendimiento, especialmente para aplicaciones que requieren un alto grado de concurrencia y eficiencia en el manejo de memoria. Esto sugiere una oportunidad para explorar Rust como una alternativa viable para el desarrollo de bibliotecas de fotos FOSS en el futuro.

Por lo general, se suele hacer uso de un almacenamiento de objetos ya implementado, como puede ser MinIO, que es compatible con S3. Esto permite una mayor escalabilidad y flexibilidad en el almacenamiento de grandes volúmenes de datos, lo cual es esencial para aplicaciones que manejan grandes bibliotecas de fotos.
Aún así, sería interesante explorar la posibilidad de implementar un almacenamiento de objetos propio, ya que esto podría ofrecer ventajas en términos de personalización y optimización para casos de uso específicos como puede ser el caso en el que ya se tiene un almacenamiento de archivos en el servidor y se quiere aprovechar para almacenar las fotos.

\subsection{Estudio de Tecnologías}

Tal y como se puede ver en el apartado anterior, hay una tendencia general a usar Typescript o Go para el desarrollo de el servidor de sincronización de multimedia y Flutter o PWA para el desarrollo de aplicaciones móviles. Sin embargo, existen otras tecnologías que pueden ofrecer ventajas significativas en términos de rendimiento, seguridad y facilidad de desarrollo.

En este caso, se va a estudiar el uso de Rust para el desarrollo del servidor de sincronización de multimedia, ya que ofrece un alto rendimiento y seguridad en la gestión de memoria, lo cual es crucial para aplicaciones que manejan grandes volúmenes de datos como las bibliotecas de fotos.
La seguridad que nos da Rust con su modelo de errores antes de la compilación nos va a permitir desarrollar un proyecto de código abierto más robusto y menos propenso a errores, lo cual es esencial para mantener la confianza de los usuarios en la aplicación.

Se estudiarán las tecnologías disponibles para el desarrollo de la aplicación móvil, entre ellas React Native, Flutter, PWA's y Lynxjs. Cada una de estas tecnologías tiene sus propias ventajas y desventajas, y la elección de la tecnología adecuada dependerá de los requisitos específicos del proyecto, como la necesidad de una experiencia de usuario nativa, el rendimiento en dispositivos móviles y la facilidad de desarrollo.

\subsubsection{Servidor}
El servidor de sincronización de multimedia es el componente central de la aplicación, encargado de gestionar la comunicación entre el cliente y el almacenamiento de fotos.
Disponemos de una amplia variedad a la hora de elegir un lenguaje/framework para el desarrollo del servidor, cada uno con sus propias ventajas y desventajas.

Las principales soluciones serían:
\begin{itemize}
    \item \textbf{Node.js con TypeScript}: Muy popular, especialmente para aplicaciones web. Ofrece un ecosistema rico y una gran comunidad, siendo menos eficiente en términos de rendimiento y consumo de recursos con respecto a su competencia.
    \item \textbf{Go}: Conocido por su eficiencia y facilidad de uso en aplicaciones concurrentes. Es una opción sólida para aplicaciones que requieren alto rendimiento y escalabilidad.
    \item \textbf{Rust}: Ofrece un alto rendimiento y seguridad en la gestión de memoria. Aunque tiene una curva de aprendizaje más pronunciada, es ideal para aplicaciones que requieren alta concurrencia y eficiencia.
    \item \textbf{Python}: Muy utilizado en el ámbito de la ciencia de datos y aprendizaje automático, pero menos eficiente en términos de rendimiento y escalabilidad para aplicaciones web, además de contar con un tipado dinámico que puede llevar a errores en tiempo de ejecución.
    \item \textbf{Java}: Aunque es robusto y escalable, su complejidad y consumo de recursos lo hacen menos atractivo para aplicaciones ligeras.
    \item \textbf{Ruby on Rails}: Muy popular para aplicaciones web, pero menos eficiente en términos de rendimiento y escalabilidad. No se ha trabajado mucho con esta tecnología, por lo que no se tiene una experiencia directa con ella.
\end{itemize}

Dado que para nuestro proyecto buscamos la solución más eficiente (tanto en términos de velocidad como recursos) y segura, el análisis se puede reducir a una comparación entre Go y Rust, lenguajes que ofrecen un alto rendimiento y seguridad en la gestión de memoria.

Rust y Go son dos lenguajes de programación modernos que han ganado una popularidad considerable en los últimos años, especialmente en el desarrollo de sistemas y aplicaciones de alto rendimiento. Aunque ambos comparten objetivos como la eficiencia y la concurrencia, sus filosofías de diseño y enfoques para resolver problemas difieren significativamente.

\textbf{Rust} es un lenguaje de programación de sistemas enfocado en la seguridad de memoria y la concurrencia. Su principal objetivo es ofrecer el rendimiento de C/C++ sin los problemas comunes de gestión de memoria, como los punteros nulos o las carreras de datos, gracias a su sistema de propiedad (ownership) y préstamos (borrowing).

\textbf{Go} (también conocido como Golang) es un lenguaje desarrollado por Google, diseñado para ser simple, eficiente y productivo, especialmente para la programación concurrente y de redes. Prioriza la simplicidad en su sintaxis y herramientas, facilitando una curva de aprendizaje suave.

\paragraph{Gestión de Memoria}
\subparagraph{Rust}
Rust implementa un sistema de gestión de memoria único basado en los conceptos de \textit{ownership}, \textit{borrowing} y \textit{lifetimes}. Este sistema garantiza la seguridad de memoria en tiempo de compilación sin necesidad de un recolector de basura (Garbage Collector - GC).

El sistema de gestión de memoria de Rust se basa en las siguientes reglas:
\begin{itemize}
    \item Cada valor en Rust tiene un único propietario (owner).
    \item Cuando el propietario sale del ámbito, el valor se libera automáticamente.
    \item Los valores pueden ser prestados (borrowed) de forma mutable o inmutable, pero no ambos al mismo tiempo.
    \item Solamente puede haber un préstamo mutable o múltiples préstamos inmutables a un valor al mismo tiempo. Un préstamo mutable no puede existir a la vez que un préstamo inmutable, dado que podría llevar a condiciones de carrera.
    \item Los préstamos tienen una duración (lifetime) que garantiza que los datos referenciados sigan siendo válidos durante su uso. El tiempo de vida de los préstamos se determina en tiempo de compilación, lo que evita errores comunes de punteros nulos o dangling pointers.
\end{itemize}

Gracias a ello, tenemos control preciso sobre la memoria, ausencia de pausas por GC, prevención de fugas de memoria y carreras de datos de forma estática. El compilador será muy estricto, lo que hará que prevengamos errores en tiempo de ejecución.

Todo este paradigma de programación es totalmente distinto a lo que estamos acostumbrados en otros lenguajes de programación como puede ser Java o c++/c, lo que puede llevar a una curva de aprendizaje más pronunciada, pero a largo plazo nos va a permitir desarrollar aplicaciones más seguras y eficientes.

\subparagraph{Go}
Go utiliza un recolector de basura para la gestión automática de la memoria. Este GC está optimizado para baja latencia, aunque introduce ciertas pausas.
\begin{itemize}
    \item \textbf{Ventajas:} Simplifica la gestión de memoria para el desarrollador, haciendo más sencillo el desarrollo de aplicaciones concurrentes. El lenguaje es más fácil de aprender y usar, especialmente para principiantes.
    \item \textbf{Desventajas:} Introduce una sobrecarga (overhead) y posibles pausas no determinísticas debido al GC, lo que puede ser un inconveniente en aplicaciones de tiempo real estricto.
\end{itemize}

\paragraph{Rendimiento}
\subparagraph{Rust}
Rust está diseñado para ofrecer un rendimiento comparable al de C y C++. Sus abstracciones de "coste cero" aseguran que las características de alto nivel no impongan una penalización en tiempo de ejecución. La ausencia de GC también contribuye a un rendimiento predecible.

Rust ofrece varias abstracciones de coste cero como \texttt{iterators}, \texttt{closures} y \texttt{async/await} que permiten escribir código limpio y expresivo sin sacrificar el rendimiento. Además, su sistema de tipos y el modelo de propiedad permiten al compilador realizar optimizaciones agresivas que en otro lenguaje son imposibles.

En el rendimiento podemos distinguir entre dos aspectos:
\begin{itemize}
    \item \textbf{Compilación:} Los tiempos de compilación pueden ser más largos debido a las exhaustivas verificaciones que realiza el compilador.
    \item \textbf{Ejecución:} Muy alta velocidad de ejecución y uso eficiente de los recursos.
\end{itemize}

\subparagraph{Go}
Go ofrece un buen rendimiento, aunque generalmente no alcanza el nivel de Rust o C++ en tareas que requieren máxima optimización a bajo nivel. Su compilador es notablemente rápido.

Go utiliza un modelo de concurrencia basado en goroutines y canales, lo que permite un alto grado de paralelismo sin complicaciones adicionales. Esto lo hace ideal para aplicaciones que requieren manejar múltiples tareas simultáneamente, como servidores web o servicios de red.

\begin{itemize}
    \item \textbf{Compilación:} Tiempos de compilación muy rápidos, lo que agiliza el ciclo de desarrollo.
    \item \textbf{Ejecución:} Buen rendimiento para la mayoría de las aplicaciones, especialmente en I/O y concurrencia. El GC\footnote{Garbage collector} puede impactar el rendimiento en ciertos escenarios.
\end{itemize}

\paragraph{Concurrencia}
\subparagraph{Rust}
Rust aborda la concurrencia con un enfoque en la seguridad ("fearless concurrency"). Su sistema de tipos y el modelo de propiedad previenen las carreras de datos en tiempo de compilación. Utiliza primitivas como \texttt{async/await} para la programación asíncrona, además de hilos de sistema operativo, consiguiendo paralelismo para la programación asíncrona.

Rust permite la creación de hilos seguros y eficientes, y su modelo de propiedad garantiza que no haya condiciones de carrera. El compilador verifica en tiempo de compilación que no se acceda a datos compartidos de forma insegura gracias a su modelo de propiedad de variables, lo que reduce significativamente los errores comunes en la programación concurrente.
\begin{itemize}
    \item \textbf{Ventajas:} Concurrencia segura sin carreras de datos garantizada por el compilador. Buen soporte para paralelismo.
    \item \textbf{Desventajas:} La programación concurrente puede ser más verbosa o compleja de configurar inicialmente en comparación con Go.
\end{itemize}

\subparagraph{Go}
La concurrencia es una de las características estrella de Go. Se basa en \textit{goroutines} (hilos ligeros gestionados por el runtime de Go) y \textit{canales} (channels) para la comunicación entre goroutines, siguiendo el paradigma de "Comunicación Secuencial de Procesos" (CSP).
Éste se basa en la idea de que las goroutines se comunican entre sí a través de canales sin acceder a las mismas posiciones de memoria (cada goroutine tiene su propia copia de el mensaje) y reduce el riesgo de condiciones de carrera.
Si queremos tener una comunicación bidireccional, tendríamos que utilizar un enfoque más tradicional mediante mutexs o semáforos junto con locks, lo cual puede ser más complejo y propenso a errores.
\begin{itemize}
    \item \textbf{Ventajas:} Modelo de concurrencia muy simple y potente. Facilidad para escribir software concurrente y paralelo.
    \item \textbf{Desventajas:} Aunque las goroutines son ligeras, una mala gestión puede llevar a problemas de rendimiento o fugas de goroutines. Las carreras de datos son posibles y deben ser manejadas por el desarrollador.
\end{itemize}

\paragraph{Sintaxis y Curva de Aprendizaje}
\subparagraph{Rust}
La sintaxis de Rust es moderna y expresiva, pero su sistema de tipos y el modelo de gestión de memoria (ownership y borrowing) introducen una curva de aprendizaje considerablemente más pronunciada que la de Go.
Ya se ha trabajado anteriormente con Rust, lo cual facilita el aprendizaje de este lenguaje.
Además, la documentación oficial de Rust es muy completa y está bien estructurada, lo que ayuda a los nuevos usuarios a familiarizarse con el lenguaje.
\begin{itemize}
    \item \textbf{Ventajas:} Sintaxis potente que permite un control muy granular.
    \item \textbf{Desventajas:} Dificultad inicial alta para dominar los conceptos clave.
\end{itemize}

\subparagraph{Go}
Go fue diseñado con la simplicidad como uno de sus principios fundamentales. Su sintaxis es minimalista y fácil de aprender, especialmente para programadores con experiencia en lenguajes tipo C.
\begin{itemize}
    \item \textbf{Ventajas:} Curva de aprendizaje suave, alta legibilidad y productividad rápida.
    \item \textbf{Desventajas:} La simplicidad puede llevar a cierta verbosidad en algunos casos (por ejemplo, el manejo de errores antes de la versión 1.13 con \texttt{wrap error}). Algunos patrones comunes de otros lenguajes no tienen un equivalente directo.
\end{itemize}

\paragraph{Sistema de Tipos y Abstracciones}
\subparagraph{Rust}
Rust posee un sistema de tipos estático, fuerte y muy rico, inspirado en lenguajes como Haskell. Incluye \textit{traits} (similares a interfaces pero más potentes), genéricos avanzados, tipos de datos algebraicos (ADTs\footnote{Los ADTs (Algebraic Data Types) pueden ser de dos tipos: de Producto (combinación de varios valores en una sola variable) o de Suma (Representan valores que pueden ser de una de varias variantes)}) como \texttt{enum} y \texttt{struct} que, gracias a el pattern matching\footnote{El pattern matching en Rust es una forma de comparar y desestructurar valores usando la instrucción match. Permite ejecutar código según la forma y contenido de un valor, de manera segura y exhaustiva.}, y macros para metaprogramación.
\begin{itemize}
    \item \textbf{Ventajas:} Gran expresividad, seguridad de tipos, permite abstracciones potentes y seguras.
    \item \textbf{Desventajas:} Puede resultar complejo para quienes vienen de lenguajes con sistemas de tipos más simples.
\end{itemize}

\subparagraph{Go}
Go tiene un sistema de tipos estático y simple. Utiliza interfaces para la polimorfismo de forma implícita (tipado estructural). Los genéricos fueron añadidos en la versión 1.18, lo que ha expandido sus capacidades de abstracción.
\begin{itemize}
    \item \textbf{Ventajas:} Simplicidad en el sistema de tipos, interfaces fáciles de usar. La adición de genéricos ha mejorado la reutilización de código.
    \item \textbf{Desventajas:} Menos expresivo que el sistema de tipos de Rust. Antes de los genéricos, la falta de ellos era una limitación importante.
\end{itemize}

\paragraph{Ecosistema y Herramientas}
\subparagraph{Rust}
Rust cuenta con \textbf{Cargo}, una herramienta de gestión de dependencias y construcción de proyectos muy elogiada. El repositorio oficial de paquetes es \textbf{crates.io}, que alberga una cantidad creciente de bibliotecas.

Cargo además ofrece herramientas integradas para pruebas, documentación y gestión de versiones.
\begin{itemize}
    \item \textbf{Ventajas:} Herramientas robustas y unificadas. Comunidad activa y creciente.
    \item \textbf{Desventajas:} Aunque el ecosistema está creciendo rápidamente, puede no ser tan maduro como el de Go en ciertas áreas específicas (ej. algunas bibliotecas para servicios web muy específicos).
\end{itemize}

\subparagraph{Go}
Go posee una excelente librería estándar que cubre muchas necesidades comunes, especialmente en networking y servicios web. Sus herramientas de desarrollo (formateo, testing, profiling) están integradas en la distribución del lenguaje. Utiliza módulos de Go para la gestión de dependencias.
\begin{itemize}
    \item \textbf{Ventajas:} Librería estándar muy completa. Herramientas simples y efectivas. Compilación cruzada sencilla.
    \item \textbf{Desventajas:} Menor cantidad de bibliotecas de terceros para ciertos dominios muy especializados en comparación con lenguajes más antiguos, aunque el ecosistema es maduro para sus casos de uso principales.
\end{itemize}

\paragraph{Manejo de Errores}
\subparagraph{Rust}
Rust no utiliza excepciones. El manejo de errores se realiza principalmente a través de los tipos \texttt{Result<T, E>} y \texttt{Option<T>} y el pattern matching exhaustivo, que obligan al programador a considerar los casos de éxito y error explícitamente.
\begin{itemize}
    \item \textbf{Ventajas:} Manejo de errores robusto y explícito, que previene errores no gestionados.
    \item \textbf{Desventajas:} Puede resultar verboso en comparación con las excepciones, aunque el operador \texttt{?}\footnote{El operador ? devuelve el error si ocurre sin necesidad de introducir un \textit{match}} ayuda a mitigar esto.
\end{itemize}

\subparagraph{Go}
Go maneja los errores retornándolos como el último valor de una función. Por convención, un error es un valor que satisface la interfaz \texttt{error}. Esto requiere comprobaciones explícitas \texttt{if err != nil}.
El manejo de errores en este caso no es exhaustivo.
\begin{itemize}
    \item \textbf{Ventajas:} Simple y explícito.
    \item \textbf{Desventajas:} Puede llevar a código repetitivo y verboso con múltiples comprobaciones de error.
\end{itemize}

\paragraph{Casos de Uso Principales}
\subparagraph{Rust}
\begin{itemize}
    \item Programación de sistemas (sistemas operativos, navegadores web).
    \item Motores de videojuegos.
    \item Herramientas de línea de comandos (CLI).
    \item Desarrollo de WebAssembly (Wasm).
    \item Sistemas embebidos.
    \item Aplicaciones que requieren alto rendimiento y seguridad de memoria.
\end{itemize}

\subparagraph{Go}
\begin{itemize}
    \item Servicios de backend y microservicios.
    \item Herramientas de red y servidores.
    \item Herramientas de DevOps y CLI.
    \item Bases de datos distribuidas.
    \item Aplicaciones concurrentes.
\end{itemize}

\paragraph{Resumen de Ventajas y Desventajas}

\subparagraph{Rust}
\textbf{Ventajas:}
\begin{itemize}
    \item Seguridad de memoria sin recolector de basura.
    \item Alto rendimiento, comparable a C/C++.
    \item Concurrencia segura ("fearless concurrency").
    \item Sistema de tipos rico y expresivo.
    \item Excelente gestor de paquetes y herramientas (Cargo).
    \item Creciente popularidad en dominios críticos.
\end{itemize}
\textbf{Desventajas:}
\begin{itemize}
    \item Curva de aprendizaje pronunciada.
    \item Tiempos de compilación más lentos.
    \item Mayor verbosidad en algunos aspectos debido a la gestión de memoria y errores.
\end{itemize}

\subparagraph{Go}
\textbf{Ventajas:}
\begin{itemize}
    \item Simplicidad y facilidad de aprendizaje.
    \item Modelo de concurrencia simple y potente (goroutines, channels).
    \item Tiempos de compilación muy rápidos.
    \item Librería estándar robusta.
    \item Buena productividad para el desarrollo de servicios de red.
    \item Respaldo de Google y una comunidad madura.
\end{itemize}
\textbf{Desventajas:}
\begin{itemize}
    \item Rendimiento generalmente inferior a Rust en cómputo intensivo.
    \item El recolector de basura puede introducir latencias.
    \item El sistema de tipos es menos expresivo que el de Rust (aunque mejorado con genéricos).
    \item El manejo de errores puede ser verboso.
\end{itemize}

\paragraph{Conclusión}
\subparagraph{}
Para este caso, cualquiera de las dos soluciones sería completamente válida. Go podría ser la mejor opción por su enfoque en la simplicidad y la facilidad de uso, especialmente para aplicaciones web y servicios de red. Sin embargo, Rust ofrece ventajas significativas en términos de seguridad de memoria y rendimiento, lo que lo convierte en una opción atractiva para aplicaciones que requieren alta concurrencia y eficiencia.

En nuestro proyecto se busca alto rendimiento, seguridad, facilidad de contribuir al proyecto y un lenguaje sólido que no sea propenso a fallos.
Es por esto que Rust es la mejor opción en nuestro caso.

Tal como se ha comentado anteriormente, Rust nos facilita seguridad en la ejecución del código gracias a su estricto compilador.
Nos ofrece una gran variedad de funcionalidades sin coste en rendimiento junto con su sistema de propiedad y préstamos que nos permite gestionar la memoria de forma segura y eficiente, evitando errores comunes como las carreras de datos o los punteros nulos sin necesidad de un recolector de basura (GC).

Aunque la curva de aprendizaje de Rust es más pronunciada, los beneficios a largo plazo en términos de seguridad y rendimiento justifican esta inversión inicial.

Invertir en aprender este lenguaje no solo nos favorecerá para el desarrollo de este proyecto, sino que también nos proporcionará habilidades valiosas para futuros proyectos en el ámbito del desarrollo de software, el cual al final es uno de los objetivos de hacer un proyecto de este tamaño.

Trabajar con tecnologías y paradigmas de programación con las que no estamos familiarizados nos va a ayudar a mejorar nuestras habilidades y ampliar nuestro conocimiento en el desarrollo de software, lo cual es esencial para nuestro crecimiento profesional.

\subsubsection{Aplicación Móvil}

Para el desarrollo de aplicaciones móviles en el contexto de bibliotecas de fotos, existen varias tecnologías que ofrecen diferentes enfoques y características. A continuación se presenta un análisis detallado de las principales opciones disponibles.

\paragraph{React Native}

React Native, desarrollado por Meta (Facebook), permite crear aplicaciones móviles nativas utilizando JavaScript y React. Es ampliamente adoptado en la industria y cuenta con un ecosistema maduro.

\textbf{Arquitectura y Funcionamiento:}
\begin{itemize}
    \item Utiliza un bridge para comunicar JavaScript con componentes nativos
    \item Renderiza componentes nativos reales, no WebViews
    \item Permite integración de código nativo cuando es necesario
    \item Soporte para hot reload durante el desarrollo
\end{itemize}

\textbf{Ventajas:}
\begin{itemize}
    \item \textbf{Ecosistema maduro}: Gran cantidad de bibliotecas y componentes disponibles
    \item \textbf{Comunidad activa}: Amplio soporte de la comunidad y documentación extensa
    \item \textbf{Desarrollo rápido}: Reutilización de código entre iOS y Android (70-80\%)
    \item \textbf{Performance nativa}: Acceso directo a APIs nativas del dispositivo
    \item \textbf{Flexibilidad}: Posibilidad de escribir módulos nativos cuando sea necesario
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item \textbf{Bridge overhead}: La comunicación JavaScript-nativo puede introducir latencias
    \item \textbf{Tamaño de aplicación}: Las aplicaciones tienden a ser más grandes debido a las dependencias
    \item \textbf{Fragmentación}: Diferentes versiones pueden tener incompatibilidades
    \item \textbf{Limitaciones de UI}: Algunos componentes complejos requieren implementación nativa
\end{itemize}

\paragraph{Flutter}

Flutter, desarrollado por Google, utiliza el lenguaje Dart y un enfoque único de renderizado que dibuja todos los componentes desde cero utilizando Skia.

\textbf{Arquitectura y Funcionamiento:}
\begin{itemize}
    \item Engine compilado en C++ que renderiza directamente con Skia
    \item Framework en Dart que gestiona widgets y estado
    \item Compilación ahead-of-time (AOT) para producción
    \item Hot reload y hot restart para desarrollo
\end{itemize}

\textbf{Ventajas:}
\begin{itemize}
    \item \textbf{Rendimiento consistente}: 60fps garantizados en la mayoría de dispositivos
    \item \textbf{UI personalizable}: Control total sobre cada píxel de la interfaz
    \item \textbf{Consistencia multiplataforma}: Misma apariencia en iOS y Android
    \item \textbf{Desarrollo productivo}: Hot reload extremadamente rápido
    \item \textbf{Compilación nativa}: Sin bridge, comunicación directa con APIs nativas
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item \textbf{Curva de aprendizaje}: Dart es menos conocido que JavaScript
    \item \textbf{Tamaño de aplicación}: El engine de Flutter añade peso significativo (4-8MB base)
    \item \textbf{Ecosistema más joven}: Menos bibliotecas de terceros comparado con React Native
    \item \textbf{Plataformas específicas}: Algunas funcionalidades requieren plugins específicos
    \item \textbf{Limitaciones de integración}: Puede ser complicado integrar con código nativo existente
    \item \textbf{Renderizado sobre motor gráfico}: Dado que no renderiza de manera nativa, puede ser menos eficiente en dispositivos de gama baja
\end{itemize}

\paragraph{Progressive Web Apps (PWA)}

Las PWA representan una evolución de las aplicaciones web tradicionales, ofreciendo características similares a las aplicaciones nativas mediante tecnologías web estándar.

\textbf{Arquitectura y Funcionamiento:}
\begin{itemize}
    \item Service Workers para funcionalidad offline y caché
    \item Web App Manifest para instalación y apariencia nativa
    \item Responsive design para adaptación a diferentes dispositivos
    \item APIs web modernas para acceso a funcionalidades del dispositivo
\end{itemize}

\textbf{Ventajas:}
\begin{itemize}
    \item \textbf{Desarrollo unificado}: Una sola base de código para web y móvil
    \item \textbf{Distribución sencilla}: No requiere app stores, actualización automática
    \item \textbf{Peso reducido}: Generalmente más ligeras que aplicaciones nativas
    \item \textbf{Accesibilidad}: Funcionan en cualquier dispositivo con navegador moderno
    \item \textbf{SEO}: Indexables por motores de búsqueda
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item \textbf{Limitaciones de API}: Acceso restringido a funcionalidades nativas
    \item \textbf{Rendimiento}: Inferior a aplicaciones nativas para tareas intensivas
    \item \textbf{Experiencia de usuario}: Puede sentirse menos "nativa"
    \item \textbf{Soporte variable}: Diferencias de implementación entre navegadores
    \item \textbf{Distribución}: Menor visibilidad sin presencia en app stores
\end{itemize}

\paragraph{Lynxjs}

Lynxjs representa una tecnología emergente que promete combinar el desarrollo web con el rendimiento nativo, aunque su adopción y madurez son significativamente menores que las alternativas establecidas.

\textbf{Arquitectura y Funcionamiento:}
\begin{itemize}
    \item Runtime nativo que ejecuta JavaScript sin WebView
    \item Compilación just-in-time optimizada para móviles
    \item Bridge optimizado para comunicación JavaScript-nativo
    \item Soporte para APIs nativas modernas
    \item Uso de doble thread para mejorar el rendimiento y experiencia de usuario
\end{itemize}

\textbf{Ventajas:}
\begin{itemize}
    \item \textbf{Rendimiento optimizado}: Promete mejor rendimiento que React Native gracias a su ejecución con doble thread
    \item \textbf{Tamaño reducido}: Runtime más ligero que Flutter
    \item \textbf{Desarrollo familiar}: Utiliza JavaScript/TypeScript estándar
    \item \textbf{APIs modernas}: Soporte nativo para funcionalidades actuales
    \item \textbf{Interoperabilidad}: Posibilidad de integrar código nativo fácilmente, de manera similar a React Native
    \item \textbf{Actualizaciones}: Desarrollado y utilizado por el equipo de TikTok, lo que promete actualizaciones y mejoras constantes
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item \textbf{Tecnología inmadura}: Ecosistema limitado y documentación escasa
    \item \textbf{Comunidad pequeña}: Pocos recursos y ejemplos disponibles
    \item \textbf{Estabilidad}: Versiones alpha/beta con cambios frecuentes
    \item \textbf{Compatibilidad}: Posibles problemas con bibliotecas existentes
\end{itemize}

\subsubsection{Comparación Técnica de Tecnologías Móviles}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Criterio} & \textbf{React Native} & \textbf{Flutter} & \textbf{PWA} & \textbf{Lynxjs} \\
\hline
Rendimiento & 7/10 & 9/10 & 5/10 & 8/10* \\
Ecosistema & 9/10 & 8/10 & 8/10 & 3/10 \\
Curva Aprendizaje & 6/10 & 7/10 & 9/10 & 7/10 \\
Tamaño App & 6/10 & 5/10 & 9/10 & 8/10* \\
Acceso Nativo & 9/10 & 9/10 & 4/10 & 8/10* \\
Desarrollo Rápido & 8/10 & 9/10 & 9/10 & 6/10 \\
Estabilidad & 9/10 & 8/10 & 8/10 & 4/10 \\
Comunidad & 9/10 & 8/10 & 7/10 & 2/10 \\
\hline
\multicolumn{5}{|l|}{*Datos basados en especificaciones, experiencia limitada} \\
\hline
\end{tabular}
\caption{Comparación de tecnologías para desarrollo móvil}
\label{tab:mobile_tech_comparison}
\end{table}

\subsubsection{Análisis de Rendimiento para Bibliotecas de Fotos}

Para aplicaciones de gestión de fotos, ciertos aspectos del rendimiento son particularmente críticos:

\paragraph{Procesamiento de Imágenes}
\begin{itemize}
    \item \textbf{Flutter}: Excelente para manipulación de imágenes gracias a Skia
    \item \textbf{React Native}: Requiere bibliotecas nativas para procesamiento intensivo
    \item \textbf{PWA}: Limitado a Canvas API y WebGL, rendimiento variable
    \item \textbf{Lynxjs}: Promete buen rendimiento, pero sin datos empíricos
\end{itemize}

\paragraph{Gestión de Memoria}
\begin{itemize}
    \item \textbf{Flutter}: Control granular de memoria, garbage collection optimizado
    \item \textbf{React Native}: Dependiente de JavaScript GC, posibles memory leaks
    \item \textbf{PWA}: Gestión automática del navegador, limitaciones en dispositivos antiguos
    \item \textbf{Lynxjs}: Optimizaciones prometidas pero no verificadas
\end{itemize}

\paragraph{Carga y Visualización}
\begin{itemize}
    \item \textbf{Flutter}: Lazy loading nativo y caching eficiente
    \item \textbf{React Native}: Buenas bibliotecas para lazy loading (react-native-fast-image)
    \item \textbf{PWA}: Service Workers para caching, pero limitaciones de almacenamiento
    \item \textbf{Lynxjs}: Lazy loading integrado y optimizado mediante componente específico para carga de datos/imágenes
\end{itemize}

\subsubsection{Consideraciones Específicas para el Proyecto}

Dado que el proyecto busca crear una biblioteca de fotos FOSS competitiva, la elección de tecnología móvil debe considerar:

\paragraph{Criterios de Decisión}
\begin{enumerate}
    \item \textbf{Rendimiento}: Crítico para manipulación de grandes colecciones de fotos
    \item \textbf{Experiencia de Usuario}: Debe rivalizar con soluciones comerciales
    \item \textbf{Facilidad de Contribución}: Importante para proyectos FOSS
    \item \textbf{Sostenibilidad}: Tecnología con futuro asegurado
\end{enumerate}

\paragraph{Conclusiones}
Basándose en el análisis comparativo y los requisitos específicos del proyecto:

\textbf{Flutter es una opción sólida} por las siguientes razones:
\begin{itemize}
    \item Consistencia multiplataforma ideal para FOSS
    \item Ecosistema maduro con soporte a largo plazo de Google
    \item Buena integración con APIs, aunque integración con RPCs limitada
    \item Comunidad activa en proyectos de código abierto
\end{itemize}

\textbf{React Native podría ser la mejor opción} si se prioriza:
\begin{itemize}
    \item Familiaridad del equipo con JavaScript
    \item Acceso a un ecosistema más amplio de bibliotecas
    \item Flexibilidad para integraciones nativas específicas
\end{itemize}

\textbf{PWA es una mala opción} ya que:
\begin{itemize}
    \item Se requiera distribución app stores, de forma no nativa
    \item Bajo rendimiento a la hora de realizar tareas intensivas de procesamiento de imágenes
    \item Limitaciones en acceso a funcionalidades nativas del dispositivo
\end{itemize}

\textbf{Lynxjs es una opción arriesgada} aunque ofrece ventajas como:
\begin{itemize}
    \item Rendimiento optimizado y menor tamaño de aplicación
    \item Desarrollo familiar con JavaScript/TypeScript
    \item Potencial para mejorar la experiencia de usuario en comparación con React Native
\end{itemize}

Para el desarrollo de este proyecto se va a optar por usar \textbf{Lynxjs}.

Aunque es una elección que puede parecer arriesgada, se ha considerado que el rendimiento optimizado y la familiaridad con JavaScript/TypeScript son factores clave para el éxito del proyecto.
Además, el hecho de que Lynxjs esté respaldado por TikTok sugiere un compromiso a largo plazo con la tecnología, lo que puede ofrecer estabilidad y actualizaciones continuas.

Se ha descartado React Native ya que Lynxjs ofrece prácticamente las mismas ventajas, pero con un rendimiento optimizado gracias a componentes específicos optimizados, un tamaño de aplicación más reducido y un acceso más directo a las APIs nativas del dispositivo.

Flutter aun ofreciendo una gran cantidad de ventajas se ha descartado por lo siguiente:
\begin{itemize}
    \item El tamaño de la aplicación es significativamente mayor que el de Lynxjs, lo cual puede ser un inconveniente para los usuarios con dispositivos de gama baja.
    \item Aunque ofrece un rendimiento excelente, la curva de aprendizaje de Dart puede ser un obstáculo para algunos desarrolladores, especialmente si ya están familiarizados con JavaScript/TypeScript, lo cual afectaría a la facilidad de contribuir al proyecto.
    \item Para dispositivos de gama baja, además de el tamaño de la aplicación, el rendimiento puede verse afectado por el uso intensivo del motor gráfico de Flutter, lo que podría resultar en una experiencia de usuario deficiente.
    \item El acceso a funcionalidades nativas puede ser más complicado en comparación con Lynxjs, que permite una integración más directa con el código nativo existente.
\end{itemize}
Cabe destacar que Flutter habría sido la mejor elección si el objetivo del proyecto no fuera crear una aplicación FOSS, ya que el ecosistema de Typescript y JavaScript es más amplio y maduro, lo que facilita la integración con bibliotecas y herramientas existentes.

\paragraph{Tecnologías no nombradas}
Durante el análisis nos hemos centrado en aquellas tecnologías que son más populares y ampliamente utilizadas en la industria, pero existen otras opciones que podrían ser consideradas dependiendo de los requisitos específicos del proyecto como podría ser el desarrollo nativo (Kotlin/Java para Android y Swift/Objective-C para iOS) o Kotlin Multiplatform.

Se han descartado debido a la alta curva de aprendizaje que tienen ambas soluciones en comparación con las anteriormente nombradas que usan lenguajes de programación más usados. Destacar que, aunque Kotlin Multiplaform nos ofrece una de las mejores alternativas para implementar en varias plataformas (ya que nos permite compartir código entre Android, iOS y web gracias a Jetpack Compose, implementando de forma sencilla y totalmente nativa funcionalidades específicas), la falta de madurez en su ecosistema y la complejidad de su implementación lo hacen menos atractivo para nuestro proyecto.
